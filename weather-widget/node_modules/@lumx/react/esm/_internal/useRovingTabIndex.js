import { i as _toConsumableArray, c as _objectSpread2, _ as _defineProperty, f as _slicedToArray } from './getRootClassName.js';
import { createContext, useContext, useMemo, useEffect, useCallback } from 'react';
import { u as uid } from '../index2.js';

var INIT_STATE = {
  isLazy: true,
  shouldActivateOnFocus: false,
  activeTabIndex: 0,
  ids: {
    tab: [],
    tabPanel: []
  }
};
var reducer = function reducer(state, action) {
  switch (action.type) {
    case 'update':
      return _objectSpread2({}, state, {}, action.payload);

    case 'setActiveTabIndex':
      {
        if (state.activeTabIndex === action.payload) {
          return state;
        } // Change active tab index.


        return _objectSpread2({}, state, {
          activeTabIndex: action.payload
        });
      }

    case 'register':
      {
        var _action$payload = action.payload,
            type = _action$payload.type,
            id = _action$payload.id; // Append tab/tabPanel id in state.

        return _objectSpread2({}, state, {
          ids: _objectSpread2({}, state.ids, _defineProperty({}, type, [].concat(_toConsumableArray(state.ids[type]), [id])))
        });
      }

    case 'unregister':
      {
        var _action$payload2 = action.payload,
            _type = _action$payload2.type,
            _id = _action$payload2.id;

        var index = state.ids[_type].indexOf(_id);

        if (index === -1) return state; // Remove tab & tab panel at index.

        var tabIds = _toConsumableArray(state.ids.tab);

        tabIds.splice(index, 1);

        var tabPanelIds = _toConsumableArray(state.ids.tabPanel);

        tabPanelIds.splice(index, 1);
        return _objectSpread2({}, state, {
          ids: {
            tab: tabIds,
            tabPanel: tabPanelIds
          }
        });
      }

    default:
      return state;
  }
};
var TabProviderContext = createContext(null);

/* eslint-disable react-hooks/rules-of-hooks */
var useTabProviderContext = function useTabProviderContext(type, originalId) {
  var context = useContext(TabProviderContext);

  if (!context) {
    return undefined;
  }

  var _context = _slicedToArray(context, 2),
      state = _context[0],
      dispatch = _context[1]; // Current tab or tab panel id.


  var id = useMemo(function () {
    return originalId || "".concat(type, "-").concat(uid());
  }, // eslint-disable-next-line react-hooks/exhaustive-deps
  []);
  useEffect(function () {
    // On mount: register tab or tab panel id.
    dispatch({
      type: 'register',
      payload: {
        type: type,
        id: id
      }
    });
    return function () {
      // On unmount: unregister tab or tab panel id.
      dispatch({
        type: 'unregister',
        payload: {
          type: type,
          id: id
        }
      });
    };
  }, // eslint-disable-next-line react-hooks/exhaustive-deps
  []); // Find tab/tabPanel index using it's id.

  var index = useMemo(function () {
    return state.ids[type].indexOf(id);
  }, [state.ids, type, id]);
  var tabId = useMemo(function () {
    return state.ids.tab[index] || '';
  }, [state, index]);
  var tabPanelId = useMemo(function () {
    return state.ids.tabPanel[index] || '';
  }, [state, index]);
  var isActive = useMemo(function () {
    return state.activeTabIndex === index;
  }, [state, index]);
  var changeToTab = useCallback(function () {
    return dispatch({
      type: 'setActiveTabIndex',
      payload: index
    });
  }, [dispatch, index]);
  return {
    isLazy: state.isLazy,
    shouldActivateOnFocus: state.shouldActivateOnFocus,
    tabId: tabId,
    tabPanelId: tabPanelId,
    isActive: isActive,
    changeToTab: changeToTab
  };
};
var useTabProviderContextState = function useTabProviderContextState() {
  var context = useContext(TabProviderContext);
  return context === null || context === void 0 ? void 0 : context[0];
};

var useRovingTabIndex = function useRovingTabIndex(_ref) {
  var parentRef = _ref.parentRef,
      elementSelector = _ref.elementSelector,
      keepTabIndex = _ref.keepTabIndex,
      _ref$extraDependencie = _ref.extraDependencies,
      extraDependencies = _ref$extraDependencie === void 0 ? [] : _ref$extraDependencie;
  useEffect(function () {
    var parent = parentRef === null || parentRef === void 0 ? void 0 : parentRef.current;

    if (!parent) {
      return undefined;
    }

    var elements = parent.querySelectorAll(elementSelector);
    var initialFocusableElement = parent === null || parent === void 0 ? void 0 : parent.querySelector("".concat(elementSelector, "[tabindex=\"0\"]"));

    var handleKeyDown = function handleKeyDown(index) {
      return function (evt) {
        var newTabFocus = index;

        if (!(evt.key === 'ArrowRight' || evt.key === 'ArrowLeft')) {
          return;
        }

        if (evt.key === 'ArrowRight') {
          // Move right
          newTabFocus += 1; // If we're at the end, go to the start

          if (newTabFocus >= elements.length) {
            newTabFocus = 0;
          }
        } else if (evt.key === 'ArrowLeft') {
          // Move left
          newTabFocus -= 1;

          if (newTabFocus < 0) {
            // If we're at the start, move to the end
            newTabFocus = elements.length - 1;
          }
        }

        var newElement = elements[newTabFocus];
        newElement === null || newElement === void 0 ? void 0 : newElement.focus();

        if (keepTabIndex) {
          evt.currentTarget.setAttribute('tabindex', '-1');
          newElement === null || newElement === void 0 ? void 0 : newElement.setAttribute('tabindex', '0');
        }
      };
    };

    if ((elements === null || elements === void 0 ? void 0 : elements.length) > 0) {
      elements.forEach(function (el, key) {
        // if no element has tabindex set to 0, set the first element as focusable
        if (!initialFocusableElement && key === 0) {
          el.setAttribute('tabindex', '0'); // set all other to -1
        } else if (initialFocusableElement !== el) {
          el.setAttribute('tabindex', '-1');
        } // add event listener


        el.addEventListener('keydown', handleKeyDown(key));
      });
    } // Cleanup listeners


    return function () {
      if ((elements === null || elements === void 0 ? void 0 : elements.length) > 0) {
        elements.forEach(function (el, key) {
          el.removeEventListener('keydown', handleKeyDown(key));
        });
      }
    };
  }, // eslint-disable-next-line react-hooks/exhaustive-deps
  [parentRef].concat(_toConsumableArray(extraDependencies)));
};

export { INIT_STATE as I, TabProviderContext as T, useTabProviderContextState as a, useTabProviderContext as b, reducer as r, useRovingTabIndex as u };
//# sourceMappingURL=useRovingTabIndex.js.map
