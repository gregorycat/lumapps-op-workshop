import { l as onEscapePressed, i as _toConsumableArray } from './getRootClassName.js';
import React, { useEffect, createContext, useContext } from 'react';
import isEmpty from 'lodash/isEmpty';
import { D as DOCUMENT } from './constants.js';
import pull from 'lodash/pull';

/**
 * Triggers a callback when the escape key is pressed.
 *
 * @param callback      Callback
 * @param closeOnEscape Disables the hook when false
 * @param rootElement   Element on which to listen the escape key
 */

function useCallbackOnEscape(callback) {
  var closeOnEscape = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
  var rootElement = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : DOCUMENT === null || DOCUMENT === void 0 ? void 0 : DOCUMENT.body;
  useEffect(function () {
    if (closeOnEscape && callback && rootElement) {
      var onKeyDown = onEscapePressed(callback);
      rootElement.addEventListener('keydown', onKeyDown);
      return function () {
        return rootElement.removeEventListener('keydown', onKeyDown);
      };
    }

    return undefined;
  }, [callback, closeOnEscape, rootElement]);
}

var EVENT_TYPES = ['mousedown', 'touchstart'];

function isClickAway(target, refs) {
  // The target element is not contained in any of the listed element references.
  return !refs.some(function (e) {
    var _e$current;

    return e === null || e === void 0 ? void 0 : (_e$current = e.current) === null || _e$current === void 0 ? void 0 : _e$current.contains(target);
  });
}

/**
 * Listen to clicks away from the given elements and callback the passed in function.
 *
 * Warning: If you need to detect click away on nested React portals, please use the `ClickAwayProvider` component.
 */
function useClickAway(_ref) {
  var callback = _ref.callback,
      refs = _ref.refs;
  useEffect(function () {
    var currentRefs = refs.current;

    if (!callback || !currentRefs || isEmpty(currentRefs)) {
      return undefined;
    }

    var listener = function listener(evt) {
      if (isClickAway(evt.target, currentRefs)) {
        callback(evt);
      }
    };

    EVENT_TYPES.forEach(function (evtType) {
      return document.addEventListener(evtType, listener);
    });
    return function () {
      EVENT_TYPES.forEach(function (evtType) {
        return document.removeEventListener(evtType, listener);
      });
    };
  }, [callback, refs]);
}

var ClickAwayAncestorContext = createContext(null);
/**
 * Component combining the `useClickAway` hook with a React context to hook into the React component tree and make sure
 * we take into account both the DOM tree and the React tree we trying to detect click away.
 *
 * @return the react component.
 */

var ClickAwayProvider = function ClickAwayProvider(_ref) {
  var children = _ref.children,
      callback = _ref.callback,
      refs = _ref.refs;
  var ancestorChildrenRefs = useContext(ClickAwayAncestorContext);
  useEffect(function () {
    var currentRefs = refs.current;

    var _ref2 = ancestorChildrenRefs || {},
        currentAncestorChildrenRefs = _ref2.current;

    if (!currentAncestorChildrenRefs || !currentRefs) {
      return undefined;
    } // Push current refs to parent.


    currentAncestorChildrenRefs.push.apply(currentAncestorChildrenRefs, _toConsumableArray(currentRefs));
    return function () {
      // Pull current refs from parent.
      pull.apply(void 0, [currentAncestorChildrenRefs].concat(_toConsumableArray(currentRefs)));
    };
  }, [ancestorChildrenRefs, refs]);
  useClickAway({
    callback: callback,
    refs: refs
  });
  return React.createElement(ClickAwayAncestorContext.Provider, {
    value: refs
  }, children);
};
ClickAwayProvider.displayName = 'ClickAwayProvider';

export { ClickAwayProvider as C, useCallbackOnEscape as u };
//# sourceMappingURL=ClickAwayProvider.js.map
