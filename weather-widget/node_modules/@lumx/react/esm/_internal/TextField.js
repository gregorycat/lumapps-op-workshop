import { Size, Theme, Emphasis, Kind } from './components.js';
import { g as getRootClassName, a as _objectWithoutProperties, f as _slicedToArray, d as classnames, h as handleBasicClasses, c as _objectSpread2, b as _extends } from './getRootClassName.js';
import React, { forwardRef, useMemo, useState, useRef, useEffect } from 'react';
import { c as mdiAlertCircle, b as mdiCheckCircle, n as mdiCloseCircle } from './mdi.js';
import { u as uid } from '../index2.js';
import get from 'lodash/get';
import { m as mergeRefs } from './mergeRefs.js';
import { I as IconButton } from './IconButton.js';
import { I as Icon } from './Icon2.js';
import { I as InputHelper } from './InputHelper.js';
import { I as InputLabel } from './InputLabel.js';

/**
 * Defines the props of the component.
 */

/**
 * Component display name.
 */
var COMPONENT_NAME = 'TextField';
/**
 * Component default class name and class prefix.
 */

var CLASSNAME = getRootClassName(COMPONENT_NAME);
/**
 * Default minimum number of rows in the multiline mode.
 */

var DEFAULT_MIN_ROWS = 2;
/**
 * Component default props.
 */

var DEFAULT_PROPS = {
  theme: Theme.light,
  type: 'text'
};
/**
 * Hook that allows to calculate the number of rows needed for a text area.
 * @param minimumRows Minimum number of rows that we want to display.
 * @return rows to be used and a callback to recalculate
 */

var useComputeNumberOfRows = function useComputeNumberOfRows(minimumRows) {
  var _useState = useState(minimumRows),
      _useState2 = _slicedToArray(_useState, 2),
      rows = _useState2[0],
      setRows = _useState2[1];

  var recompute = function recompute(target) {
    /**
     * HEAD's UP! This part is a little bit tricky. The idea here is to only
     * display the necessary rows on the textarea. In order to dynamically adjust
     * the height on that field, we need to:
     * 1. Set the current amount of rows to the minimum. That will make the scroll appear.
     * 2. With that, we will have the `scrollHeight`, meaning the height of the container adjusted to the current content
     * 3. With the scroll height, we can figure out how many rows we need to use by dividing the scroll height
     * by the line height.
     * 4. With that number, we can readjust the number of rows on the text area. We need to do that here, if we leave that to
     * the state change through React, there are some scenarios (resize, hitting ENTER or BACKSPACE which add or remove lines)
     * when we will not see the update and the rows will be resized to the minimum.
     * 5. In case there is any other update on the component that changes the UI, we need to keep the number of rows
     * on the state in order to allow React to re-render. Therefore, we save them using `useState`
     */
    // eslint-disable-next-line no-param-reassign
    target.rows = minimumRows;
    var currentRows = target.scrollHeight / (target.clientHeight / minimumRows);
    currentRows = currentRows >= minimumRows ? currentRows : minimumRows; // eslint-disable-next-line no-param-reassign

    target.rows = currentRows;
    setRows(currentRows);
  };

  return {
    recomputeNumberOfRows: recompute,
    rows: rows
  };
};

var renderInputNative = function renderInputNative(props) {
  var id = props.id,
      isDisabled = props.isDisabled,
      isRequired = props.isRequired,
      placeholder = props.placeholder,
      multiline = props.multiline,
      value = props.value,
      setFocus = props.setFocus,
      onChange = props.onChange,
      onFocus = props.onFocus,
      onBlur = props.onBlur,
      inputRef = props.inputRef,
      rows = props.rows,
      recomputeNumberOfRows = props.recomputeNumberOfRows,
      type = props.type,
      name = props.name,
      forwardedProps = _objectWithoutProperties(props, ["id", "isDisabled", "isRequired", "placeholder", "multiline", "value", "setFocus", "onChange", "onFocus", "onBlur", "inputRef", "rows", "recomputeNumberOfRows", "type", "name"]); // eslint-disable-next-line react-hooks/rules-of-hooks


  var ref = useRef(null); // eslint-disable-next-line react-hooks/rules-of-hooks

  useEffect(function () {
    // Recompute the number of rows for the first rendering
    if (multiline && ref && ref.current) {
      recomputeNumberOfRows(ref.current);
    }
  }, [ref, multiline, recomputeNumberOfRows, value]);

  var onTextFieldFocus = function onTextFieldFocus(event) {
    onFocus === null || onFocus === void 0 ? void 0 : onFocus(event);
    setFocus(true);
  };

  var onTextFieldBlur = function onTextFieldBlur(event) {
    onBlur === null || onBlur === void 0 ? void 0 : onBlur(event);
    setFocus(false);
  };

  var handleChange = function handleChange(event) {
    onChange(get(event, 'target.value'), name, event);
  };

  var Component = multiline ? 'textarea' : 'input';

  var inputProps = _objectSpread2({}, forwardedProps, {
    id: id,
    className: multiline ? "".concat(CLASSNAME, "__input-native ").concat(CLASSNAME, "__input-native--textarea") : "".concat(CLASSNAME, "__input-native ").concat(CLASSNAME, "__input-native--text"),
    placeholder: placeholder,
    value: value,
    name: name,
    disabled: isDisabled,
    required: isRequired,
    onFocus: onTextFieldFocus,
    onBlur: onTextFieldBlur,
    onChange: handleChange,
    ref: mergeRefs(inputRef, ref)
  });

  if (multiline) {
    inputProps.rows = rows;
  } else {
    inputProps.type = type;
  }

  return React.createElement(Component, inputProps);
};
/**
 * TextField component.
 *
 * @param  props Component props.
 * @param  ref   Component ref.
 * @return React element.
 */


var TextField = forwardRef(function (props, ref) {
  var chips = props.chips,
      className = props.className,
      clearButtonProps = props.clearButtonProps,
      disabled = props.disabled,
      error = props.error,
      forceFocusStyle = props.forceFocusStyle,
      hasError = props.hasError,
      helper = props.helper,
      icon = props.icon,
      id = props.id,
      inputRef = props.inputRef,
      _props$isDisabled = props.isDisabled,
      isDisabled = _props$isDisabled === void 0 ? disabled : _props$isDisabled,
      isRequired = props.isRequired,
      isValid = props.isValid,
      label = props.label,
      maxLength = props.maxLength,
      minimumRows = props.minimumRows,
      multiline = props.multiline,
      name = props.name,
      onBlur = props.onBlur,
      onChange = props.onChange,
      onFocus = props.onFocus,
      placeholder = props.placeholder,
      textFieldRef = props.textFieldRef,
      theme = props.theme,
      type = props.type,
      value = props.value,
      forwardedProps = _objectWithoutProperties(props, ["chips", "className", "clearButtonProps", "disabled", "error", "forceFocusStyle", "hasError", "helper", "icon", "id", "inputRef", "isDisabled", "isRequired", "isValid", "label", "maxLength", "minimumRows", "multiline", "name", "onBlur", "onChange", "onFocus", "placeholder", "textFieldRef", "theme", "type", "value"]);

  var textFieldId = useMemo(function () {
    return id || "text-field-".concat(uid());
  }, [id]);

  var _useState3 = useState(false),
      _useState4 = _slicedToArray(_useState3, 2),
      isFocus = _useState4[0],
      setFocus = _useState4[1];

  var _useComputeNumberOfRo = useComputeNumberOfRows(multiline ? minimumRows || DEFAULT_MIN_ROWS : 0),
      rows = _useComputeNumberOfRo.rows,
      recomputeNumberOfRows = _useComputeNumberOfRo.recomputeNumberOfRows;

  var valueLength = (value || '').length;
  var isNotEmpty = valueLength > 0;
  /**
   * Function triggered when the Clear Button is clicked.
   * The idea is to execute the `onChange` callback with an empty string
   * and remove focus from the clear button.
   * @param evt On clear event.
   */

  var onClear = function onClear(evt) {
    evt.nativeEvent.preventDefault();
    evt.nativeEvent.stopPropagation();
    evt.currentTarget.blur();
    onChange('');
  };

  return React.createElement("div", {
    ref: ref,
    className: classnames(className, handleBasicClasses({
      hasChips: Boolean(chips),
      hasError: !isValid && hasError,
      hasIcon: Boolean(icon),
      hasInput: !multiline,
      hasInputClear: clearButtonProps && isNotEmpty,
      hasLabel: Boolean(label),
      hasPlaceholder: Boolean(placeholder),
      hasTextarea: multiline,
      hasValue: Boolean(value),
      isDisabled: isDisabled,
      isFocus: isFocus || forceFocusStyle,
      isValid: isValid,
      prefix: CLASSNAME,
      theme: theme
    }))
  }, label && React.createElement("div", {
    className: "".concat(CLASSNAME, "__header")
  }, React.createElement(InputLabel, {
    htmlFor: textFieldId,
    className: "".concat(CLASSNAME, "__label"),
    isRequired: isRequired,
    theme: theme
  }, label), maxLength && React.createElement("div", {
    className: "".concat(CLASSNAME, "__char-counter")
  }, React.createElement("span", null, maxLength - valueLength), maxLength - valueLength === 0 && React.createElement(Icon, {
    icon: mdiAlertCircle,
    size: Size.xxs
  }))), React.createElement("div", {
    className: "".concat(CLASSNAME, "__wrapper"),
    ref: textFieldRef
  }, icon && React.createElement(Icon, {
    className: "".concat(CLASSNAME, "__input-icon"),
    color: theme === Theme.dark ? 'light' : undefined,
    icon: icon,
    size: Size.xs
  }), chips && React.createElement("div", {
    className: "".concat(CLASSNAME, "__chips")
  }, chips, renderInputNative(_objectSpread2({
    id: textFieldId,
    inputRef: inputRef,
    isDisabled: isDisabled,
    isRequired: isRequired,
    maxLength: maxLength,
    multiline: multiline,
    onBlur: onBlur,
    onChange: onChange,
    onFocus: onFocus,
    placeholder: placeholder,
    recomputeNumberOfRows: recomputeNumberOfRows,
    rows: rows,
    setFocus: setFocus,
    type: type,
    value: value,
    name: name
  }, forwardedProps))), !chips && React.createElement("div", {
    className: "".concat(CLASSNAME, "__input-wrapper")
  }, renderInputNative(_objectSpread2({
    id: textFieldId,
    inputRef: inputRef,
    isDisabled: isDisabled,
    isRequired: isRequired,
    maxLength: maxLength,
    multiline: multiline,
    onBlur: onBlur,
    onChange: onChange,
    onFocus: onFocus,
    placeholder: placeholder,
    recomputeNumberOfRows: recomputeNumberOfRows,
    rows: rows,
    setFocus: setFocus,
    type: type,
    value: value,
    name: name
  }, forwardedProps))), (isValid || hasError) && React.createElement(Icon, {
    className: "".concat(CLASSNAME, "__input-validity"),
    color: theme === Theme.dark ? 'light' : undefined,
    icon: isValid ? mdiCheckCircle : mdiAlertCircle,
    size: Size.xxs
  }), clearButtonProps && isNotEmpty && React.createElement(IconButton, _extends({}, clearButtonProps, {
    className: "".concat(CLASSNAME, "__input-clear"),
    icon: mdiCloseCircle,
    emphasis: Emphasis.low,
    size: Size.s,
    theme: theme,
    onClick: onClear,
    type: "button"
  }))), hasError && error && React.createElement(InputHelper, {
    className: "".concat(CLASSNAME, "__helper"),
    kind: Kind.error,
    theme: theme
  }, error), helper && React.createElement(InputHelper, {
    className: "".concat(CLASSNAME, "__helper"),
    theme: theme
  }, helper));
});
TextField.displayName = COMPONENT_NAME;
TextField.className = CLASSNAME;
TextField.defaultProps = DEFAULT_PROPS;

export { TextField as T };
//# sourceMappingURL=TextField.js.map
