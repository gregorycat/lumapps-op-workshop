import { f as _slicedToArray } from './getRootClassName.js';
import { useState, useEffect, useRef } from 'react';

/**
 * Returns true if the component is visible taking into account the component's
 * own visibility and the animations delay
 *
 * @param isComponentVisible Whether the component intends to be visible or not.
 * @param transitionDuration time in ms that the transition takes for the specific component.
 * @param onVisibilityChange Callback called when the visibility changes.
 * @return true if the component should be rendered
 */

function useDelayedVisibility(isComponentVisible, transitionDuration, onVisibilityChange) {
  // Delay visibility to account for the 400ms of CSS opacity animation.
  var _useState = useState(isComponentVisible),
      _useState2 = _slicedToArray(_useState, 2),
      isVisible = _useState2[0],
      setVisible = _useState2[1];

  useEffect(function () {
    if (isComponentVisible) {
      setVisible(true);
    } else {
      setTimeout(function () {
        return setVisible(false);
      }, transitionDuration);
    }
  }, [isComponentVisible, transitionDuration]);
  /**
   * Since we don't want onVisibiltyChange function to trigger itself if when it changes,
   * we store the previous visibility and only trigger when visibility is different
   * than previous value.
   */

  var previousVisibility = useRef(isVisible);
  useEffect(function () {
    if (onVisibilityChange && previousVisibility.current !== isVisible) {
      onVisibilityChange(isVisible);
      previousVisibility.current = isVisible;
    }
  }, [isVisible, onVisibilityChange]);
  return isComponentVisible || isVisible;
}

export { useDelayedVisibility as u };
//# sourceMappingURL=useDelayedVisibility.js.map
