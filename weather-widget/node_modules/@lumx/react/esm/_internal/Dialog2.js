import { Size } from './components.js';
import { f as _slicedToArray, i as _toConsumableArray, g as getRootClassName, a as _objectWithoutProperties, b as _extends, d as classnames, h as handleBasicClasses, D as DIALOG_TRANSITION_DURATION } from './getRootClassName.js';
import React, { useState, useEffect, forwardRef, useRef, useMemo, Children } from 'react';
import { D as DOCUMENT } from './constants.js';
import { p as partitionMulti } from './partitionMulti.js';
import { i as isComponent } from './type.js';
import { m as mergeRefs } from './mergeRefs.js';
import { u as useFocusTrap } from './useFocusTrap.js';
import { createPortal } from 'react-dom';
import { u as useCallbackOnEscape, C as ClickAwayProvider } from './ClickAwayProvider.js';
import { u as useDelayedVisibility } from './useDelayedVisibility.js';
import { u as useDisableBodyScroll } from './useDisableBodyScroll.js';
import { a as Progress, P as ProgressVariant } from './Progress2.js';

/**
 * Convenient hook to create interaction observers.
 *
 * @param elements Elements to observe.
 * @param options  IntersectionObserver options.
 * @return Map of intersections.
 */
function useIntersectionObserver(elements, options) {
  var _useState = useState(function () {
    return new Map();
  }),
      _useState2 = _slicedToArray(_useState, 2),
      intersections = _useState2[0],
      setIntersections = _useState2[1];

  useEffect(function () {
    if (elements.length < 1 || !elements.some(Boolean)) {
      return undefined;
    }

    var observer = new IntersectionObserver(function (entries) {
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = entries[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var entry = _step.value;
          intersections.set(entry.target, entry);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      setIntersections(new Map(intersections));
    }, options);
    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
      for (var _iterator2 = elements[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
        var element = _step2.value;

        if (element) {
          observer.observe(element);
        }
      }
    } catch (err) {
      _didIteratorError2 = true;
      _iteratorError2 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
          _iterator2.return();
        }
      } finally {
        if (_didIteratorError2) {
          throw _iteratorError2;
        }
      }
    }

    return function () {
      return observer.disconnect();
    };
  }, // eslint-disable-next-line react-hooks/exhaustive-deps
  _toConsumableArray(elements));
  return intersections;
}

/**
 * Defines the props of the component.
 */

var isHeader = isComponent('header');
var isFooter = isComponent('footer');
/**
 * Component display name.
 */

var COMPONENT_NAME = 'Dialog';
/**
 * Component default class name and class prefix.
 */

var CLASSNAME = getRootClassName(COMPONENT_NAME);
/**
 * Component default props.
 */

var DEFAULT_PROPS = {
  size: Size.big
};
/**
 * Dialog component.
 *
 * @param  props Component props.
 * @param  ref   Component ref.
 * @return React element.
 */

var Dialog = forwardRef(function (props, ref) {
  var _ref, _intersections$get, _ref2, _intersections$get2, _ref3, _ref4;

  if (!DOCUMENT) {
    // Can't render in SSR.
    return null;
  }

  var children = props.children,
      className = props.className,
      header = props.header,
      focusElement = props.focusElement,
      forceFooterDivider = props.forceFooterDivider,
      forceHeaderDivider = props.forceHeaderDivider,
      footer = props.footer,
      isLoading = props.isLoading,
      isOpen = props.isOpen,
      onClose = props.onClose,
      parentElement = props.parentElement,
      contentRef = props.contentRef,
      preventAutoClose = props.preventAutoClose,
      size = props.size,
      zIndex = props.zIndex,
      dialogProps = props.dialogProps,
      onVisibilityChange = props.onVisibilityChange,
      forwardedProps = _objectWithoutProperties(props, ["children", "className", "header", "focusElement", "forceFooterDivider", "forceHeaderDivider", "footer", "isLoading", "isOpen", "onClose", "parentElement", "contentRef", "preventAutoClose", "size", "zIndex", "dialogProps", "onVisibilityChange"]);

  var handleClose = onClose ? function () {
    onClose(); // Focus the parent element on close.

    if (parentElement && parentElement.current) {
      parentElement.current.focus();
    }
  } : undefined; // eslint-disable-next-line react-hooks/rules-of-hooks

  useCallbackOnEscape(handleClose, isOpen && !preventAutoClose); // eslint-disable-next-line react-hooks/rules-of-hooks

  var wrapperRef = useRef(null);
  /**
   * Since the `contentRef` comes from the parent and is optional,
   * we need to create a stable contentRef that will always be available.
   */
  // eslint-disable-next-line react-hooks/rules-of-hooks

  var localContentRef = useRef(null); // Handle focus trap.
  // eslint-disable-next-line react-hooks/rules-of-hooks

  useFocusTrap(wrapperRef.current, focusElement === null || focusElement === void 0 ? void 0 : focusElement.current); // eslint-disable-next-line react-hooks/rules-of-hooks

  useDisableBodyScroll(isOpen && localContentRef.current); // eslint-disable-next-line react-hooks/rules-of-hooks

  var _useState = useState(null),
      _useState2 = _slicedToArray(_useState, 2),
      sentinelTop = _useState2[0],
      setSentinelTop = _useState2[1]; // eslint-disable-next-line react-hooks/rules-of-hooks


  var _useState3 = useState(null),
      _useState4 = _slicedToArray(_useState3, 2),
      sentinelBottom = _useState4[0],
      setSentinelBottom = _useState4[1]; // eslint-disable-next-line react-hooks/rules-of-hooks


  var intersections = useIntersectionObserver([sentinelTop, sentinelBottom], {
    threshold: [0, 1]
  });
  var hasTopIntersection = sentinelTop && !((_ref = (_intersections$get = intersections.get(sentinelTop)) === null || _intersections$get === void 0 ? void 0 : _intersections$get.isIntersecting) !== null && _ref !== void 0 ? _ref : true);
  var hasBottomIntersection = sentinelBottom && !((_ref2 = (_intersections$get2 = intersections.get(sentinelBottom)) === null || _intersections$get2 === void 0 ? void 0 : _intersections$get2.isIntersecting) !== null && _ref2 !== void 0 ? _ref2 : true); // Separate header, footer and dialog content from children.
  // eslint-disable-next-line react-hooks/rules-of-hooks

  var _useMemo = useMemo(function () {
    return partitionMulti(Children.toArray(children), [isHeader, isFooter]);
  }, [children]),
      _useMemo2 = _slicedToArray(_useMemo, 3),
      _useMemo2$ = _slicedToArray(_useMemo2[0], 1),
      headerChild = _useMemo2$[0],
      _useMemo2$2 = _slicedToArray(_useMemo2[1], 1),
      footerChild = _useMemo2$2[0],
      content = _useMemo2[2];

  var headerChildProps = (_ref3 = headerChild) === null || _ref3 === void 0 ? void 0 : _ref3.props;
  var headerChildContent = headerChildProps === null || headerChildProps === void 0 ? void 0 : headerChildProps.children;
  var footerChildProps = (_ref4 = footerChild) === null || _ref4 === void 0 ? void 0 : _ref4.props;
  var footerChildContent = footerChildProps === null || footerChildProps === void 0 ? void 0 : footerChildProps.children; // eslint-disable-next-line react-hooks/rules-of-hooks

  var isVisible = useDelayedVisibility(Boolean(isOpen), DIALOG_TRANSITION_DURATION, onVisibilityChange); // eslint-disable-next-line react-hooks/rules-of-hooks

  var clickAwayRefs = useRef([wrapperRef]);
  return isOpen || isVisible ? createPortal(React.createElement("div", _extends({
    ref: ref
  }, forwardedProps, {
    className: classnames(className, handleBasicClasses({
      isHidden: !isOpen,
      isLoading: isLoading,
      isShown: isOpen || isVisible,
      prefix: CLASSNAME,
      size: size
    })),
    style: {
      zIndex: zIndex
    }
  }), React.createElement("div", {
    className: "".concat(CLASSNAME, "__overlay")
  }), React.createElement("section", _extends({
    className: "".concat(CLASSNAME, "__container"),
    role: "dialog",
    "aria-modal": "true"
  }, dialogProps), React.createElement(ClickAwayProvider, {
    callback: !preventAutoClose && handleClose,
    refs: clickAwayRefs
  }, React.createElement("div", {
    className: "".concat(CLASSNAME, "__wrapper"),
    ref: wrapperRef
  }, (header || headerChildContent) && React.createElement("header", _extends({}, headerChildProps, {
    className: classnames("".concat(CLASSNAME, "__header"), (forceHeaderDivider || hasTopIntersection) && "".concat(CLASSNAME, "__header--has-divider"), headerChildProps === null || headerChildProps === void 0 ? void 0 : headerChildProps.className)
  }), header, headerChildContent), React.createElement("div", {
    ref: mergeRefs(contentRef, localContentRef),
    className: "".concat(CLASSNAME, "__content")
  }, React.createElement("div", {
    className: "".concat(CLASSNAME, "__sentinel ").concat(CLASSNAME, "__sentinel--top"),
    ref: setSentinelTop
  }), content, React.createElement("div", {
    className: "".concat(CLASSNAME, "__sentinel ").concat(CLASSNAME, "__sentinel--bottom"),
    ref: setSentinelBottom
  })), (footer || footerChildContent) && React.createElement("footer", _extends({}, footerChildProps, {
    className: classnames("".concat(CLASSNAME, "__footer"), (forceFooterDivider || hasBottomIntersection) && "".concat(CLASSNAME, "__footer--has-divider"), footerChildProps === null || footerChildProps === void 0 ? void 0 : footerChildProps.className)
  }), footer, footerChildContent), isLoading && React.createElement("div", {
    className: "".concat(CLASSNAME, "__progress-overlay")
  }, React.createElement(Progress, {
    variant: ProgressVariant.circular
  })))))), document.body) : null;
});
Dialog.displayName = COMPONENT_NAME;
Dialog.className = CLASSNAME;
Dialog.defaultProps = DEFAULT_PROPS;

export { Dialog as D };
//# sourceMappingURL=Dialog2.js.map
