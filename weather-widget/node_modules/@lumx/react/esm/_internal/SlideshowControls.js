import { Theme, Emphasis } from './components.js';
import { g as getRootClassName, a as _objectWithoutProperties, f as _slicedToArray, b as _extends, d as classnames, h as handleBasicClasses, _ as _defineProperty, k as detectHorizontalSwipe } from './getRootClassName.js';
import React, { useRef, useEffect, forwardRef, useState, useCallback, useMemo } from 'react';
import { g as mdiChevronLeft, f as mdiChevronRight } from './mdi.js';
import { W as WINDOW } from './constants.js';
import { m as mergeRefs } from './mergeRefs.js';
import { I as IconButton } from './IconButton.js';
import isFunction from 'lodash/isFunction';
import range from 'lodash/range';

/**
 * Autoplay default interval in ms.
 */
var AUTOPLAY_DEFAULT_INTERVAL = 5000;
/**
 * Full width size in percent.
 */

var FULL_WIDTH_PERCENT = 100;
/**
 * Edge from the active index.
 */

var EDGE_FROM_ACTIVE_INDEX = 2;
/**
 * Max number of pagination items.
 */

var PAGINATION_ITEMS_MAX = 5;
/**
 * Size of a pagination item. Used to translate wrapper.
 */

var PAGINATION_ITEM_SIZE = 12;

/**
 * Making setInterval Declarative with React Hooks.
 * Credits: https://overreacted.io/making-setinterval-declarative-with-react-hooks/
 *
 * @param callback Function called by setInterval.
 * @param     delay    Delay for setInterval.
 */
function useInterval(callback, delay) {
  var savedCallback = useRef();
  useEffect(function () {
    savedCallback.current = callback;
  });
  useEffect(function () {
    if (delay === null) return undefined;

    function tick() {
      if (isFunction(savedCallback.current)) {
        savedCallback.current();
      }
    }

    var id = setInterval(tick, delay);
    return function () {
      return clearInterval(id);
    };
  }, [delay]);
}

/**
 * Defines the props of the component.
 */

/**
 * Component display name.
 */
var COMPONENT_NAME = 'Slideshow';
/**
 * Component default class name and class prefix.
 */

var CLASSNAME = getRootClassName(COMPONENT_NAME);
/**
 * Component default props.
 */

var DEFAULT_PROPS = {
  activeIndex: 0,
  groupBy: 1,
  interval: AUTOPLAY_DEFAULT_INTERVAL,
  theme: Theme.light
};
/**
 * Slideshow component.
 *
 * @param  props Component props.
 * @param  ref   Component ref.
 * @return React element.
 */

var Slideshow = forwardRef(function (props, ref) {
  var _classNames;

  var activeIndex = props.activeIndex,
      autoPlay = props.autoPlay,
      children = props.children,
      className = props.className,
      fillHeight = props.fillHeight,
      groupBy = props.groupBy,
      interval = props.interval,
      onChange = props.onChange,
      slideshowControlsProps = props.slideshowControlsProps,
      theme = props.theme,
      forwardedProps = _objectWithoutProperties(props, ["activeIndex", "autoPlay", "children", "className", "fillHeight", "groupBy", "interval", "onChange", "slideshowControlsProps", "theme"]);

  var _useState = useState(activeIndex),
      _useState2 = _slicedToArray(_useState, 2),
      currentIndex = _useState2[0],
      setCurrentIndex = _useState2[1]; // Use state instead of a ref to make the slideshow controls update directly when the element is set.


  var _useState3 = useState(),
      _useState4 = _slicedToArray(_useState3, 2),
      element = _useState4[0],
      setElement = _useState4[1]; // Number of slideshow items.


  var itemsCount = React.Children.count(children); // Number of slides when using groupBy prop.

  var slidesCount = Math.ceil(itemsCount / Math.min(groupBy, itemsCount)); // Inline style of wrapper element.

  var wrapperStyle = {
    transform: "translateX(-".concat(FULL_WIDTH_PERCENT * currentIndex, "%)")
  }; // Change current index to display next slide.

  var goToNextSlide = useCallback(function () {
    var loopback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
    setCurrentIndex(function (index) {
      if (loopback && index === slidesCount - 1) {
        // Loopback to the start.
        return 0;
      }

      if (index < slidesCount - 1) {
        // Next slide.
        return index + 1;
      }

      return index;
    });
  }, [slidesCount, setCurrentIndex]); // Change current index to display previous slide.

  var goToPreviousSlide = useCallback(function () {
    var loopback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
    setCurrentIndex(function (index) {
      if (loopback && index === 0) {
        // Loopback to the end.
        return slidesCount - 1;
      }

      if (index > 0) {
        // Previous slide.
        return index - 1;
      }

      return index;
    });
  }, [slidesCount, setCurrentIndex]); // Auto play

  var _useState5 = useState(Boolean(autoPlay)),
      _useState6 = _slicedToArray(_useState5, 2),
      isAutoPlaying = _useState6[0],
      setIsAutoPlaying = _useState6[1]; // Start


  useInterval(goToNextSlide, isAutoPlaying && slidesCount > 1 ? interval : null); // Reset current index if it become invalid.

  useEffect(function () {
    if (currentIndex > slidesCount - 1) {
      setCurrentIndex(DEFAULT_PROPS.activeIndex);
    }
  }, [currentIndex, slidesCount]); // Handle click on a bullet to go to a specific slide.

  var handleControlGotToSlide = useCallback(function (index) {
    setIsAutoPlaying(false);

    if (index >= 0 && index < slidesCount) {
      setCurrentIndex(index);
    }
  }, [slidesCount, setCurrentIndex]); // Handle click or keyboard event to go to next slide.

  var handleControlNextSlide = useCallback(function () {
    var loopback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
    setIsAutoPlaying(false);
    goToNextSlide(loopback);
  }, [goToNextSlide]); // Handle click or keyboard event to go to previous slide.

  var handleControlPreviousSlide = useCallback(function () {
    var loopback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
    setIsAutoPlaying(false);
    goToPreviousSlide(loopback);
  }, [goToPreviousSlide]); // If the activeIndex props changes, update the current slide

  useEffect(function () {
    setCurrentIndex(activeIndex);
  }, [activeIndex]); // If the slide changes, with autoplay for example, trigger "onChange"

  useEffect(function () {
    if (!onChange) return;
    onChange(currentIndex);
  }, [currentIndex, onChange]);
  /* eslint-disable jsx-a11y/no-noninteractive-tabindex */

  return React.createElement("div", _extends({
    ref: mergeRefs(ref, setElement)
  }, forwardedProps, {
    className: classnames(className, handleBasicClasses({
      prefix: CLASSNAME,
      theme: theme
    }), (_classNames = {}, _defineProperty(_classNames, "".concat(CLASSNAME, "--fill-height"), fillHeight), _defineProperty(_classNames, "".concat(CLASSNAME, "--group-by-").concat(groupBy), Boolean(groupBy)), _classNames)),
    tabIndex: 0
  }), React.createElement("div", {
    className: "".concat(CLASSNAME, "__slides")
  }, React.createElement("div", {
    className: "".concat(CLASSNAME, "__wrapper"),
    style: wrapperStyle
  }, children)), slideshowControlsProps && slidesCount > 1 && React.createElement("div", {
    className: "".concat(CLASSNAME, "__controls")
  }, React.createElement(SlideshowControls, _extends({}, slideshowControlsProps, {
    activeIndex: currentIndex,
    onPaginationClick: handleControlGotToSlide,
    onNextClick: handleControlNextSlide,
    onPreviousClick: handleControlPreviousSlide,
    slidesCount: slidesCount,
    parentRef: element,
    theme: theme
  }))));
});
Slideshow.displayName = COMPONENT_NAME;
Slideshow.className = CLASSNAME;
Slideshow.defaultProps = DEFAULT_PROPS;

/**
 * Defines the props of the component.
 */

/**
 * Component display name.
 */
var COMPONENT_NAME$1 = 'SlideshowItem';
/**
 * Component default class name and class prefix.
 */

var CLASSNAME$1 = getRootClassName(COMPONENT_NAME$1);
/**
 * SlideshowItem component.
 *
 * @param  props Component props.
 * @param  ref   Component ref.
 * @return React element.
 */

var SlideshowItem = forwardRef(function (props, ref) {
  var className = props.className,
      children = props.children,
      forwardedProps = _objectWithoutProperties(props, ["className", "children"]);

  return React.createElement("div", _extends({
    ref: ref
  }, forwardedProps, {
    className: classnames(className, handleBasicClasses({
      prefix: CLASSNAME$1
    }))
  }), children);
});
SlideshowItem.displayName = COMPONENT_NAME$1;
SlideshowItem.className = CLASSNAME$1;

var isTouchDevice = function isTouchDevice() {
  return 'ontouchstart' in window;
};
/**
 * Listen swipe to navigate left and right.
 */


function useSwipeNavigate(element, onNext, onPrevious) {
  useEffect(function () {
    if (!element || !isTouchDevice()) return undefined;
    return detectHorizontalSwipe(element, function (swipe) {
      var callback = swipe === 'right' ? onPrevious : onNext;
      callback === null || callback === void 0 ? void 0 : callback();
    });
  }, [onPrevious, onNext, element]);
}

/**
 * Listen keyboard to navigate left and right.
 */

function useKeyNavigate(element, onNext, onPrevious) {
  useEffect(function () {
    if (!element) return undefined;

    var onKeyNavigate = function onKeyNavigate(evt) {
      var callback;

      if ((evt === null || evt === void 0 ? void 0 : evt.key) === 'ArrowRight') {
        callback = onPrevious;
      } else if ((evt === null || evt === void 0 ? void 0 : evt.key) === 'ArrowLeft') {
        callback = onNext;
      }

      if (!callback) return;
      callback();
      evt.preventDefault();
      evt.stopPropagation();
    };

    element.addEventListener('keydown', onKeyNavigate);
    return function () {
      element.removeEventListener('keydown', onKeyNavigate);
    };
  }, [onPrevious, onNext, element]);
}

/**
 * Calculate the currently visible pagination "bullet" range.
 */
function usePaginationVisibleRange(activeIndex, slideCount) {
  var previousVisibleRangeRef = useRef();
  return useMemo(function () {
    var lastSlide = slideCount - 1;
    var previousVisibleRange = previousVisibleRangeRef.current;
    var newVisibleRange;

    if (activeIndex === (previousVisibleRange === null || previousVisibleRange === void 0 ? void 0 : previousVisibleRange.max) && activeIndex < lastSlide) {
      newVisibleRange = {
        min: previousVisibleRange.min + 1,
        max: previousVisibleRange.max + 1
      };
    } else if (activeIndex === (previousVisibleRange === null || previousVisibleRange === void 0 ? void 0 : previousVisibleRange.min) && activeIndex > 0) {
      newVisibleRange = {
        min: previousVisibleRange.min - 1,
        max: previousVisibleRange.max - 1
      };
    } else {
      var deltaItems = PAGINATION_ITEMS_MAX - 1;
      var min = activeIndex - EDGE_FROM_ACTIVE_INDEX;
      var max = activeIndex + EDGE_FROM_ACTIVE_INDEX;

      if (activeIndex > lastSlide - EDGE_FROM_ACTIVE_INDEX) {
        min = lastSlide - deltaItems;
        max = lastSlide;
      } else if (activeIndex < deltaItems) {
        min = 0;
        max = deltaItems;
      }

      newVisibleRange = {
        min: min,
        max: max
      };
    }

    previousVisibleRangeRef.current = newVisibleRange;
    return newVisibleRange;
  }, [activeIndex, slideCount]);
}

/**
 * Defines the props of the component.
 */

/**
 * Component display name.
 */
var COMPONENT_NAME$2 = 'SlideshowControls';
/**
 * Component default class name and class prefix.
 */

var CLASSNAME$2 = getRootClassName(COMPONENT_NAME$2);
/**
 * Component default props.
 */

var DEFAULT_PROPS$1 = {
  activeIndex: 0,
  theme: Theme.light
};
/**
 * SlideshowControls component.
 *
 * @param  props Component props.
 * @param  ref   Component ref.
 * @return React element.
 */

var SlideshowControls = forwardRef(function (props, ref) {
  var activeIndex = props.activeIndex,
      className = props.className,
      nextButtonProps = props.nextButtonProps,
      onNextClick = props.onNextClick,
      onPaginationClick = props.onPaginationClick,
      onPreviousClick = props.onPreviousClick,
      parentRef = props.parentRef,
      previousButtonProps = props.previousButtonProps,
      slidesCount = props.slidesCount,
      theme = props.theme,
      forwardedProps = _objectWithoutProperties(props, ["activeIndex", "className", "nextButtonProps", "onNextClick", "onPaginationClick", "onPreviousClick", "parentRef", "previousButtonProps", "slidesCount", "theme"]);

  var parent;

  if (WINDOW) {
    // Checking window object to avoid errors in SSR.
    parent = parentRef instanceof HTMLElement ? parentRef : parentRef === null || parentRef === void 0 ? void 0 : parentRef.current;
  } // Listen to keyboard navigate left & right.


  useKeyNavigate(parent, onNextClick, onPreviousClick); // Listen to touch swipe navigate left & right.

  useSwipeNavigate(parent, // Go next without loopback.
  useCallback(function () {
    return onNextClick === null || onNextClick === void 0 ? void 0 : onNextClick(false);
  }, [onNextClick]), // Go previous without loopback.
  useCallback(function () {
    return onPreviousClick === null || onPreviousClick === void 0 ? void 0 : onPreviousClick(false);
  }, [onPreviousClick])); // Pagination "bullet" range.

  var visibleRange = usePaginationVisibleRange(activeIndex, slidesCount); // Inline style of wrapper element.

  var wrapperStyle = {
    transform: "translateX(-".concat(PAGINATION_ITEM_SIZE * visibleRange.min, "px)")
  };
  return React.createElement("div", _extends({
    ref: ref
  }, forwardedProps, {
    className: classnames(className, handleBasicClasses({
      prefix: CLASSNAME$2,
      theme: theme
    }), _defineProperty({}, "".concat(CLASSNAME$2, "--has-infinite-pagination"), slidesCount > PAGINATION_ITEMS_MAX))
  }), React.createElement(IconButton, _extends({}, previousButtonProps, {
    icon: mdiChevronLeft,
    className: "".concat(CLASSNAME$2, "__navigation"),
    color: theme === Theme.dark ? 'light' : 'dark',
    emphasis: Emphasis.low,
    onClick: onPreviousClick,
    tabIndex: -1
  })), React.createElement("div", {
    className: "".concat(CLASSNAME$2, "__pagination")
  }, React.createElement("div", {
    className: "".concat(CLASSNAME$2, "__pagination-items"),
    style: wrapperStyle
  }, useMemo(function () {
    return range(slidesCount).map(function (index) {
      var isOnEdge = index !== 0 && index !== slidesCount - 1 && (index === visibleRange.min || index === visibleRange.max);
      var isActive = activeIndex === index;
      var isOutRange = index < visibleRange.min || index > visibleRange.max;
      return (// eslint-disable-next-line jsx-a11y/control-has-associated-label
        React.createElement("button", {
          className: classnames(handleBasicClasses({
            prefix: "".concat(CLASSNAME$2, "__pagination-item"),
            isActive: isActive,
            isOnEdge: isOnEdge,
            isOutRange: isOutRange
          })),
          key: index,
          type: "button",
          onClick: function onClick() {
            return onPaginationClick === null || onPaginationClick === void 0 ? void 0 : onPaginationClick(index);
          },
          tabIndex: -1
        })
      );
    });
  }, [slidesCount, visibleRange.min, visibleRange.max, activeIndex, onPaginationClick]))), React.createElement(IconButton, _extends({}, nextButtonProps, {
    icon: mdiChevronRight,
    className: "".concat(CLASSNAME$2, "__navigation"),
    color: theme === Theme.dark ? 'light' : 'dark',
    emphasis: Emphasis.low,
    onClick: onNextClick,
    tabIndex: -1
  })));
});
SlideshowControls.displayName = COMPONENT_NAME$2;
SlideshowControls.className = CLASSNAME$2;
SlideshowControls.defaultProps = DEFAULT_PROPS$1;

export { Slideshow as S, SlideshowItem as a, SlideshowControls as b };
//# sourceMappingURL=SlideshowControls.js.map
