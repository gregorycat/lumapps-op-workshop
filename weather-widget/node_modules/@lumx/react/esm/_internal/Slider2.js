import { Theme } from './components.js';
import { g as getRootClassName, a as _objectWithoutProperties, b as _extends, d as classnames, h as handleBasicClasses } from './getRootClassName.js';
import React, { forwardRef, useMemo, useRef } from 'react';
import { u as uid } from '../index2.js';
import { I as InputHelper } from './InputHelper.js';
import { I as InputLabel } from './InputLabel.js';
import { c as clamp } from './clamp.js';

var useEnhancedEffect = typeof window !== 'undefined' ? React.useLayoutEffect : React.useEffect;
/**
 * https://github.com/facebook/react/issues/14099#issuecomment-440013892
 *
 * @param fn A function to run
 * @return A React callback
 */

function useEventCallback(fn) {
  var ref = React.useRef(fn);
  useEnhancedEffect(function () {
    ref.current = fn;
  });
  return React.useCallback(function (event) {
    return ref.current(event);
  }, []);
}

/**
 * Defines the props of the component.
 */

/**
 * Component display name.
 */
var COMPONENT_NAME = 'Slider';
/**
 * Component default class name and class prefix.
 */

var CLASSNAME = getRootClassName(COMPONENT_NAME);
/**
 * Component default props.
 */

var DEFAULT_PROPS = {
  precision: 0,
  steps: 0,
  theme: Theme.light
};
/**
 * Convert a percent value to a value in range min - max.
 *
 * @param percent   Value to convert.
 * @param min       Minimum value.
 * @param max       Maximum value.
 * @param precision Precision.
 * @return Value in range min - max
 */

var computeValueFromPercent = function computeValueFromPercent(percent, min, max) {
  var precision = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
  return Number((min + percent * (max - min)).toFixed(precision));
};
/**
 * Convert a value in range min - max to a percent value.
 *
 * @param value Value to convert.
 * @param min   Minimum value.
 * @param max   Maximum value.
 * @return Value in percent
 */


var computePercentFromValue = function computePercentFromValue(value, min, max) {
  return Number((value - min) / (max - min));
};
/**
 * Slider component.
 *
 * @param  props Component props.
 * @param  ref   Component ref.
 * @return React element.
 */


var Slider = forwardRef(function (props, ref) {
  var className = props.className,
      disabled = props.disabled,
      helper = props.helper,
      hideMinMaxLabel = props.hideMinMaxLabel,
      id = props.id,
      _props$isDisabled = props.isDisabled,
      isDisabled = _props$isDisabled === void 0 ? disabled : _props$isDisabled,
      label = props.label,
      max = props.max,
      min = props.min,
      name = props.name,
      onChange = props.onChange,
      onMouseDown = props.onMouseDown,
      precision = props.precision,
      steps = props.steps,
      theme = props.theme,
      value = props.value,
      forwardedProps = _objectWithoutProperties(props, ["className", "disabled", "helper", "hideMinMaxLabel", "id", "isDisabled", "label", "max", "min", "name", "onChange", "onMouseDown", "precision", "steps", "theme", "value"]);

  var sliderId = useMemo(function () {
    return id || "slider-".concat(uid());
  }, [id]);
  var sliderLabelId = useMemo(function () {
    return "label-".concat(sliderId);
  }, [sliderId]);
  var sliderRef = useRef(null); // build a lookup array for the steps.

  var availableSteps = useMemo(function () {
    if (!steps) return [];
    var available = [0];
    var percentStep = 1 / ((max - min) / steps);
    var ptr = 0;

    while (ptr + percentStep < 1) {
      ptr += percentStep;
      available.push(ptr);
    }

    return available;
  }, [steps, min, max]);
  /**
   * Try to find the closest step to the current slider position.
   *
   * @param percentValue Reference value
   * @return The closest step value
   */

  var findClosestStep = function findClosestStep(percentValue) {
    var closest = availableSteps.reduce(function (acc, step) {
      var aDst = Math.abs(percentValue - step);

      if (aDst < acc.dst) {
        return {
          dst: aDst,
          val: step
        };
      }

      return acc;
    }, {
      dst: Infinity,
      val: -1
    });
    return closest.val;
  };
  /**
   * Convert slider's handle position to percent.
   *
   * @param event The interaction event
   * @param slider the slider element
   * @return The computed percent value
   */


  var getPercentValue = function getPercentValue(event, slider) {
    var _slider$getBoundingCl = slider.getBoundingClientRect(),
        width = _slider$getBoundingCl.width,
        left = _slider$getBoundingCl.left;

    var percent = (event.pageX - left - window.pageXOffset) / width;
    percent = clamp(percent, 0, 1);

    if (steps) {
      percent = findClosestStep(percent);
    }

    return percent;
  };
  /**
   * Register a handler for the mouse move event.
   */


  var handleMove = useEventCallback(function (event) {
    var slider = sliderRef.current;
    if (!slider || !onChange) return;
    var newValue = getPercentValue(event, slider);
    onChange(computeValueFromPercent(newValue, min, max, precision), name, event);
  });
  /**
   * Register a handler for the mouse up event.
   * Clean a all listeners.
   */

  var handleEnd = useEventCallback(function () {
    document.body.removeEventListener('mousemove', handleMove);
    document.body.removeEventListener('mouseup', handleEnd);
    document.body.removeEventListener('touchmove', handleMove);
    document.body.removeEventListener('touchend', handleEnd);
  });
  /**
   * Move to the next or previous value (i.e. + or - 10%) or next step
   * @param previous Should seek the previous value.
   */

  var hopToValue = function hopToValue() {
    var previous = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    var oldPercent = computePercentFromValue(value, min, max);
    var percent = clamp(oldPercent + (previous ? -0.1 : 0.1), 0, 1);

    if (steps) {
      percent = oldPercent + availableSteps[1] * (previous ? -1 : 1);
      percent = findClosestStep(percent);
    }

    if (onChange) {
      onChange(computeValueFromPercent(percent, min, max, precision), name);
    }
  };
  /**
   * Register a handler for keyboard interactions
   */


  var handleKeyDown = useEventCallback(function (event) {
    if (event.key === 'ArrowRight') {
      hopToValue();
    } else if (event.key === 'ArrowLeft') {
      hopToValue(true);
    }
  });
  /**
   * Register a handler for the mouseDown event.
   */

  var handleMouseDown = useEventCallback(function (event) {
    onMouseDown === null || onMouseDown === void 0 ? void 0 : onMouseDown(event);
    var slider = sliderRef.current;
    if (isDisabled || !slider) return;
    var newValue = getPercentValue(event, slider);

    if (onChange) {
      onChange(computeValueFromPercent(newValue, min, max, precision), name, event);
    }

    document.body.addEventListener('mousemove', handleMove);
    document.body.addEventListener('mouseup', handleEnd);
  });
  var percentString = "".concat(computePercentFromValue(value, min, max) * 100, "%");
  return React.createElement("div", _extends({
    ref: ref
  }, forwardedProps, {
    className: classnames(className, handleBasicClasses({
      prefix: CLASSNAME,
      theme: theme,
      hasLabel: Boolean(label)
    })),
    onMouseDown: handleMouseDown,
    "aria-disabled": isDisabled
  }), label && React.createElement(InputLabel, {
    id: sliderLabelId,
    htmlFor: sliderId,
    className: "".concat(CLASSNAME, "__label"),
    theme: theme
  }, label), helper && React.createElement(InputHelper, {
    className: "".concat(CLASSNAME, "__helper"),
    theme: theme
  }, helper), React.createElement("div", {
    className: "".concat(CLASSNAME, "__ui-wrapper")
  }, !hideMinMaxLabel && React.createElement("span", {
    className: "".concat(CLASSNAME, "__value-label ").concat(CLASSNAME, "__value-label--min")
  }, min), React.createElement("div", {
    className: "".concat(CLASSNAME, "__wrapper"),
    ref: sliderRef
  }, React.createElement("div", {
    className: "".concat(CLASSNAME, "__track ").concat(CLASSNAME, "__track--background")
  }), React.createElement("div", {
    className: "".concat(CLASSNAME, "__track ").concat(CLASSNAME, "__track--active"),
    style: {
      width: percentString
    }
  }), steps ? React.createElement("div", {
    className: "".concat(CLASSNAME, "__ticks")
  }, availableSteps.map(function (step, idx) {
    return React.createElement("div", {
      key: "tick_".concat(idx),
      className: "".concat(CLASSNAME, "__tick"),
      style: {
        left: "".concat(step * 100, "%")
      }
    });
  })) : null, React.createElement("button", {
    type: "button",
    "aria-labelledby": sliderLabelId,
    name: name,
    id: sliderId,
    className: "".concat(CLASSNAME, "__handle"),
    style: {
      left: percentString
    },
    onKeyDown: handleKeyDown,
    disabled: isDisabled
  })), !hideMinMaxLabel && React.createElement("span", {
    className: "".concat(CLASSNAME, "__value-label ").concat(CLASSNAME, "__value-label--max")
  }, max)));
});
Slider.displayName = COMPONENT_NAME;
Slider.className = CLASSNAME;
Slider.defaultProps = DEFAULT_PROPS;

export { Slider as S };
//# sourceMappingURL=Slider2.js.map
