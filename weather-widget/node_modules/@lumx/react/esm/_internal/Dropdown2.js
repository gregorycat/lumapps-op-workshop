import { g as getRootClassName, a as _objectWithoutProperties, c as _objectSpread2, b as _extends, d as classnames, h as handleBasicClasses } from './getRootClassName.js';
import React, { useEffect, forwardRef, useRef, useMemo, cloneElement } from 'react';
import { i as isComponent } from './type.js';
import { a as Popover, P as Placement } from './Popover2.js';
import { L as List } from './List2.js';

// The error margin in px we want to have for triggering infinite scroll
var SCROLL_TRIGGER_MARGIN = 5;
/**
 * Listen to clicks away from a given element and callback the passed in function.
 *
 * @param  ref               A reference to the element on which you want to listen scroll event.
 * @param  [callback]        A callback function to call when the bottom of the reference element is reached.
 * @param  [callbackOnMount] A callback function to call when the component is mounted.
 */

var useInfiniteScroll = function useInfiniteScroll(ref, callback) {
  var callbackOnMount = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var scrollTriggerMargin = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : SCROLL_TRIGGER_MARGIN;
  useEffect(function () {
    var current = ref.current;

    if (!callback || !current) {
      return undefined;
    }

    var isAtBottom = function isAtBottom() {
      return Boolean(current && current.scrollHeight - (current.scrollTop + current.clientHeight) <= scrollTriggerMargin);
    };

    var onScroll = function onScroll(e) {
      if (isAtBottom()) {
        callback(e);
      }
    };

    if (isAtBottom()) {
      onScroll();
    }

    current.addEventListener('scroll', onScroll);
    current.addEventListener('resize', onScroll);
    return function () {
      current.removeEventListener('scroll', onScroll);
      current.removeEventListener('resize', onScroll);
    };
  }, [ref, callback, scrollTriggerMargin]);
  useEffect(function () {
    if (callback && callbackOnMount) {
      callback();
    }
  }, [callback, callbackOnMount]);
};

/**
 * Defines the props of the component.
 */

/**
 * Component display name.
 */
var COMPONENT_NAME = 'Dropdown';
/**
 * Component default class name and class prefix.
 */

var CLASSNAME = getRootClassName(COMPONENT_NAME);
/**
 * Component default props.
 */

var DEFAULT_PROPS = {
  closeOnClick: true,
  closeOnClickAway: true,
  closeOnEscape: true,
  fitToAnchorWidth: true,
  fitWithinViewportHeight: true,
  placement: Placement.BOTTOM_START,
  shouldFocusOnOpen: true
};
/**
 * Dropdown component.
 *
 * @param  props Component props.
 * @param  ref   Component ref.
 * @return React element.
 */

var Dropdown = forwardRef(function (props, ref) {
  var anchorRef = props.anchorRef,
      children = props.children,
      className = props.className,
      closeOnClick = props.closeOnClick,
      closeOnClickAway = props.closeOnClickAway,
      closeOnEscape = props.closeOnEscape,
      fitToAnchorWidth = props.fitToAnchorWidth,
      fitWithinViewportHeight = props.fitWithinViewportHeight,
      isOpen = props.isOpen,
      offset = props.offset,
      onClose = props.onClose,
      onInfiniteScroll = props.onInfiniteScroll,
      placement = props.placement,
      shouldFocusOnOpen = props.shouldFocusOnOpen,
      zIndex = props.zIndex,
      forwardedProps = _objectWithoutProperties(props, ["anchorRef", "children", "className", "closeOnClick", "closeOnClickAway", "closeOnEscape", "fitToAnchorWidth", "fitWithinViewportHeight", "isOpen", "offset", "onClose", "onInfiniteScroll", "placement", "shouldFocusOnOpen", "zIndex"]);

  var innerRef = useRef(null);
  var listElement = useRef(null);
  useInfiniteScroll(innerRef, onInfiniteScroll);
  var popperElement = useMemo(function () {
    return !Array.isArray(children) && isComponent(List)(children) ? cloneElement(children, _objectSpread2({}, children.props, {
      ref: listElement,
      onClick: function onClick(evt) {
        var _children$props$onCli, _children$props;

        (_children$props$onCli = (_children$props = children.props).onClick) === null || _children$props$onCli === void 0 ? void 0 : _children$props$onCli.call(_children$props, evt);

        if (closeOnClick) {
          onClose === null || onClose === void 0 ? void 0 : onClose();
        }
      },
      isClickable: true
    })) : children;
  }, [children, closeOnClick, onClose]);
  return isOpen ? React.createElement(Popover, _extends({
    ref: ref
  }, forwardedProps, {
    anchorRef: anchorRef,
    className: classnames(className, handleBasicClasses({
      prefix: CLASSNAME
    })),
    elevation: 0,
    closeOnClickAway: closeOnClickAway,
    closeOnEscape: closeOnEscape,
    fitToAnchorWidth: fitToAnchorWidth,
    fitWithinViewportHeight: fitWithinViewportHeight,
    focusElement: shouldFocusOnOpen ? listElement : undefined,
    isOpen: isOpen,
    offset: offset,
    onClose: onClose,
    placement: placement,
    zIndex: zIndex
  }), React.createElement("div", {
    className: "".concat(CLASSNAME, "__menu"),
    ref: innerRef
  }, popperElement)) : null;
});
Dropdown.displayName = COMPONENT_NAME;
Dropdown.className = CLASSNAME;
Dropdown.defaultProps = DEFAULT_PROPS;

export { Dropdown as D };
//# sourceMappingURL=Dropdown2.js.map
