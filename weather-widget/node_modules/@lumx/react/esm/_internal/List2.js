import { Size } from './components.js';
import { f as _slicedToArray, g as getRootClassName, a as _objectWithoutProperties, o as onEnterPressed, b as _extends, d as classnames, h as handleBasicClasses, c as _objectSpread2, j as createCommonjsModule, i as _toConsumableArray } from './getRootClassName.js';
import React, { useState, useEffect, forwardRef, useMemo, Children, isValidElement, cloneElement, useRef } from 'react';
import 'lodash/isBoolean';
import isEmpty from 'lodash/isEmpty';
import 'lodash/kebabCase';
import 'lodash/noop';
import get from 'lodash/get';
import { i as isComponent } from './type.js';
import { m as mergeRefs } from './mergeRefs.js';
import { r as renderLink } from './renderLink.js';

var INITIAL_INDEX = -1;
/**
 * This custom hook provides the necessary set of functions and values to properly navigate
 * a list using the keyboard.
 *
 * @param  items                    the list of items that will be navigated using the keyboard.
 * @param  ref                      A reference to the element that is controlling the navigation.
 * @param  onListItemSelected       callback to be executed when the ENTER key is pressed on an item.
 * @param  onListItemNavigated      callback to be executed when the Arrow keys are pressed.
 * @param  onEnterPressed           callback to be executed when the ENTER key is pressed.
 * @param  onBackspacePressed       callback to be executed when the BACKSPACE key is pressed.
 * @param  keepFocusAfterSelection  determines whether after selecting an item, the focus should be maintained on the current target or not.
 * @param  initialIndex             where should the navigation start from. it defaults to `-1`, so the first item navigated is the item on position `0`.
 * @param  preventTabOnEnteredValue determines whether upon TAB, if there is a value entered, the event is prevented or not.
 * @return useKeyboardListNavigation helpers.
 */

var useKeyboardListNavigation = function useKeyboardListNavigation(items, ref, onListItemSelected, onListItemNavigated, onEnterPressed, onBackspacePressed) {
  var keepFocusAfterSelection = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;
  var initialIndex = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : INITIAL_INDEX;
  var preventTabOnEnteredValue = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : true;

  var _useState = useState(initialIndex),
      _useState2 = _slicedToArray(_useState, 2),
      activeItemIndex = _useState2[0],
      setActiveItemIndex = _useState2[1];
  /**
   * This function calculates the next index in the list to be highlighted
   * @param key - key code pressed
   * @return next active index
   */


  var calculateActiveIndex = function calculateActiveIndex(key) {
    switch (key) {
      case 'ArrowDown':
        return activeItemIndex + 1 < items.length ? activeItemIndex + 1 : 0;

      case 'ArrowUp':
        return activeItemIndex - 1 >= 0 ? activeItemIndex - 1 : items.length - 1;

      default:
        return initialIndex;
    }
  };
  /**
   * Resets the active index to the initial state
   */


  var resetActiveIndex = function resetActiveIndex() {
    setActiveItemIndex(initialIndex);
  };
  /**
   * Prevents the default event and stops the propagation of said event
   * @param evt - key pressed event
   */


  var preventDefaultAndStopPropagation = function preventDefaultAndStopPropagation(evt) {
    evt.preventDefault();
    evt.stopPropagation();
  };
  /**
   * Handles navigation with the arrows using the keyboard
   * @param evt - key pressed event
   */


  var onArrowPressed = function onArrowPressed(evt) {
    var key = evt.key;
    var nextActiveIndex = calculateActiveIndex(key);
    setActiveItemIndex(nextActiveIndex);
    preventDefaultAndStopPropagation(evt);

    if (onListItemNavigated) {
      var selectedItem = items[nextActiveIndex];
      onListItemNavigated(selectedItem);
    }
  };
  /**
   * Handles the event when the backspace key is pressed
   * @param evt - key pressed event
   */


  var onBackspaceKeyPressed = function onBackspaceKeyPressed(evt) {
    if (onBackspacePressed) {
      onBackspacePressed(evt);
    }
  };
  /**
   * Handles when the ENTER key is pressed
   * @param evt - key pressed event
   */


  var onEnterKeyPressed = function onEnterKeyPressed(evt) {
    if (!onListItemSelected) {
      return;
    }

    preventDefaultAndStopPropagation(evt);

    if (!keepFocusAfterSelection) {
      evt.currentTarget.blur();
    }

    var selectedItem = items[activeItemIndex];

    if (selectedItem) {
      onListItemSelected(selectedItem);
      resetActiveIndex();
    } else if (activeItemIndex === initialIndex && onEnterPressed) {
      var _value = get(evt, 'target.value');

      onEnterPressed(_value);
      resetActiveIndex();
    }
  };
  /**
   * Handles when the TAB key is pressed
   * @param evt - key pressed event
   */


  var onTabKeyPressed = function onTabKeyPressed(evt) {
    var value = get(evt, 'target.value');

    if (preventTabOnEnteredValue && value && value.length > 0) {
      preventDefaultAndStopPropagation(evt);
    }
  };
  /**
   * In order to make it easier in the future to add new events depending on the key
   * a map was created to add these handlers. In the future, if there is another event
   * that we need to manage depending on a specific key, we just need to add the key code
   * here, and as a value, the handler for said key.
   */


  var eventsForKeyPressed = {
    ArrowDown: onArrowPressed,
    Tab: onTabKeyPressed,
    ArrowUp: onArrowPressed,
    Enter: onEnterKeyPressed,
    Backspace: onBackspaceKeyPressed
  };
  /**
   * Calculates the next active item index depending on the key pressed.
   * If the key pressed was ENTER, the function executes the callback `onListItemSelected`
   * and resets the active index, since an item was selected.
   * @param evt - key pressed or key down event
   */

  var onKeyboardNavigation = function onKeyboardNavigation(evt) {
    var key = evt.key;
    var handler = eventsForKeyPressed[key];

    if (handler) {
      handler(evt);
    }
  };

  useEffect(function () {
    var currentElement = ref.current;

    if (!currentElement) {
      return undefined;
    }

    currentElement.addEventListener('focus', resetActiveIndex);
    currentElement.addEventListener('keydown', onKeyboardNavigation);
    return function () {
      currentElement.removeEventListener('focus', resetActiveIndex);
      currentElement.removeEventListener('keydown', onKeyboardNavigation);
    };
  });
  return {
    activeItemIndex: activeItemIndex,
    onKeyboardNavigation: onKeyboardNavigation,
    resetActiveIndex: resetActiveIndex,
    setActiveItemIndex: setActiveItemIndex
  };
};

/**
 * Component display name.
 */
var COMPONENT_NAME = 'ListItem';
/**
 * Component default class name and class prefix.
 */

var CLASSNAME = getRootClassName(COMPONENT_NAME);
/**
 * Component default props.
 */

var DEFAULT_PROPS = {
  size: Size.regular
};
/**
 * Check if the list item is clickable.
 * @return `true` if the list item is clickable; `false` otherwise.
 */

function isClickable(_ref) {
  var linkProps = _ref.linkProps,
      onItemSelected = _ref.onItemSelected;
  return !isEmpty(linkProps === null || linkProps === void 0 ? void 0 : linkProps.href) || !!onItemSelected;
}
/**
 * ListItem component.
 *
 * @param  props Component props.
 * @param  ref   Component ref.
 * @return React element.
 */

var ListItem = forwardRef(function (props, ref) {
  var after = props.after,
      before = props.before,
      children = props.children,
      className = props.className,
      isHighlighted = props.isHighlighted,
      isSelected = props.isSelected,
      linkAs = props.linkAs,
      _props$linkProps = props.linkProps,
      linkProps = _props$linkProps === void 0 ? {} : _props$linkProps,
      linkRef = props.linkRef,
      onItemSelected = props.onItemSelected,
      size = props.size,
      forwardedProps = _objectWithoutProperties(props, ["after", "before", "children", "className", "isHighlighted", "isSelected", "linkAs", "linkProps", "linkRef", "onItemSelected", "size"]);

  var onKeyDown = useMemo(function () {
    return onItemSelected ? onEnterPressed(onItemSelected) : undefined;
  }, [onItemSelected]);
  var content = React.createElement(React.Fragment, null, before && React.createElement("div", {
    className: "".concat(CLASSNAME, "__before")
  }, before), React.createElement("div", {
    className: "".concat(CLASSNAME, "__content")
  }, children), after && React.createElement("div", {
    className: "".concat(CLASSNAME, "__after")
  }, after));
  return React.createElement("li", _extends({
    ref: ref
  }, forwardedProps, {
    className: classnames(className, handleBasicClasses({
      prefix: CLASSNAME,
      size: size
    }))
  }), isClickable({
    linkProps: linkProps,
    onItemSelected: onItemSelected
  }) ?
  /* Clickable list item */
  renderLink(_objectSpread2({
    linkAs: linkAs,
    tabIndex: 0,
    role: onItemSelected ? 'button' : undefined
  }, linkProps, {
    className: classnames(handleBasicClasses({
      prefix: "".concat(CLASSNAME, "__link"),
      isHighlighted: isHighlighted,
      isSelected: isSelected
    })),
    onClick: onItemSelected,
    onKeyDown: onKeyDown,
    ref: linkRef
  }), content) :
  /* Non clickable list item */
  React.createElement("div", {
    className: "".concat(CLASSNAME, "__wrapper")
  }, content));
});
ListItem.displayName = COMPONENT_NAME;
ListItem.className = CLASSNAME;
ListItem.defaultProps = DEFAULT_PROPS;

/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var b="function"===typeof Symbol&&Symbol.for,c=b?Symbol.for("react.element"):60103,d=b?Symbol.for("react.portal"):60106,e=b?Symbol.for("react.fragment"):60107,f=b?Symbol.for("react.strict_mode"):60108,g=b?Symbol.for("react.profiler"):60114,h=b?Symbol.for("react.provider"):60109,k=b?Symbol.for("react.context"):60110,l=b?Symbol.for("react.async_mode"):60111,m=b?Symbol.for("react.concurrent_mode"):60111,n=b?Symbol.for("react.forward_ref"):60112,p=b?Symbol.for("react.suspense"):60113,q=b?
Symbol.for("react.suspense_list"):60120,r=b?Symbol.for("react.memo"):60115,t=b?Symbol.for("react.lazy"):60116,v=b?Symbol.for("react.block"):60121,w=b?Symbol.for("react.fundamental"):60117,x=b?Symbol.for("react.responder"):60118,y=b?Symbol.for("react.scope"):60119;
function z(a){if("object"===typeof a&&null!==a){var u=a.$$typeof;switch(u){case c:switch(a=a.type,a){case l:case m:case e:case g:case f:case p:return a;default:switch(a=a&&a.$$typeof,a){case k:case n:case t:case r:case h:return a;default:return u}}case d:return u}}}function A(a){return z(a)===m}var AsyncMode=l;var ConcurrentMode=m;var ContextConsumer=k;var ContextProvider=h;var Element=c;var ForwardRef=n;var Fragment=e;var Lazy=t;var Memo=r;var Portal=d;
var Profiler=g;var StrictMode=f;var Suspense=p;var isAsyncMode=function(a){return A(a)||z(a)===l};var isConcurrentMode=A;var isContextConsumer=function(a){return z(a)===k};var isContextProvider=function(a){return z(a)===h};var isElement=function(a){return "object"===typeof a&&null!==a&&a.$$typeof===c};var isForwardRef=function(a){return z(a)===n};var isFragment=function(a){return z(a)===e};var isLazy=function(a){return z(a)===t};
var isMemo=function(a){return z(a)===r};var isPortal=function(a){return z(a)===d};var isProfiler=function(a){return z(a)===g};var isStrictMode=function(a){return z(a)===f};var isSuspense=function(a){return z(a)===p};
var isValidElementType=function(a){return "string"===typeof a||"function"===typeof a||a===e||a===m||a===g||a===f||a===p||a===q||"object"===typeof a&&null!==a&&(a.$$typeof===t||a.$$typeof===r||a.$$typeof===h||a.$$typeof===k||a.$$typeof===n||a.$$typeof===w||a.$$typeof===x||a.$$typeof===y||a.$$typeof===v)};var typeOf=z;

var reactIs_production_min = {
	AsyncMode: AsyncMode,
	ConcurrentMode: ConcurrentMode,
	ContextConsumer: ContextConsumer,
	ContextProvider: ContextProvider,
	Element: Element,
	ForwardRef: ForwardRef,
	Fragment: Fragment,
	Lazy: Lazy,
	Memo: Memo,
	Portal: Portal,
	Profiler: Profiler,
	StrictMode: StrictMode,
	Suspense: Suspense,
	isAsyncMode: isAsyncMode,
	isConcurrentMode: isConcurrentMode,
	isContextConsumer: isContextConsumer,
	isContextProvider: isContextProvider,
	isElement: isElement,
	isForwardRef: isForwardRef,
	isFragment: isFragment,
	isLazy: isLazy,
	isMemo: isMemo,
	isPortal: isPortal,
	isProfiler: isProfiler,
	isStrictMode: isStrictMode,
	isSuspense: isSuspense,
	isValidElementType: isValidElementType,
	typeOf: typeOf
};

var reactIs_development = createCommonjsModule(function (module, exports) {



if (process.env.NODE_ENV !== "production") {
  (function() {

// The Symbol used to tag the ReactElement-like types. If there is no native Symbol
// nor polyfill, then a plain number is used for performance.
var hasSymbol = typeof Symbol === 'function' && Symbol.for;
var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for('react.element') : 0xeac7;
var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for('react.portal') : 0xeaca;
var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for('react.fragment') : 0xeacb;
var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for('react.strict_mode') : 0xeacc;
var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for('react.profiler') : 0xead2;
var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for('react.provider') : 0xeacd;
var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for('react.context') : 0xeace; // TODO: We don't use AsyncMode or ConcurrentMode anymore. They were temporary
// (unstable) APIs that have been removed. Can we remove the symbols?

var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for('react.async_mode') : 0xeacf;
var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for('react.concurrent_mode') : 0xeacf;
var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for('react.forward_ref') : 0xead0;
var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for('react.suspense') : 0xead1;
var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for('react.suspense_list') : 0xead8;
var REACT_MEMO_TYPE = hasSymbol ? Symbol.for('react.memo') : 0xead3;
var REACT_LAZY_TYPE = hasSymbol ? Symbol.for('react.lazy') : 0xead4;
var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for('react.block') : 0xead9;
var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for('react.fundamental') : 0xead5;
var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for('react.responder') : 0xead6;
var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for('react.scope') : 0xead7;

function isValidElementType(type) {
  return typeof type === 'string' || typeof type === 'function' || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
  type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === 'object' && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
}

function typeOf(object) {
  if (typeof object === 'object' && object !== null) {
    var $$typeof = object.$$typeof;

    switch ($$typeof) {
      case REACT_ELEMENT_TYPE:
        var type = object.type;

        switch (type) {
          case REACT_ASYNC_MODE_TYPE:
          case REACT_CONCURRENT_MODE_TYPE:
          case REACT_FRAGMENT_TYPE:
          case REACT_PROFILER_TYPE:
          case REACT_STRICT_MODE_TYPE:
          case REACT_SUSPENSE_TYPE:
            return type;

          default:
            var $$typeofType = type && type.$$typeof;

            switch ($$typeofType) {
              case REACT_CONTEXT_TYPE:
              case REACT_FORWARD_REF_TYPE:
              case REACT_LAZY_TYPE:
              case REACT_MEMO_TYPE:
              case REACT_PROVIDER_TYPE:
                return $$typeofType;

              default:
                return $$typeof;
            }

        }

      case REACT_PORTAL_TYPE:
        return $$typeof;
    }
  }

  return undefined;
} // AsyncMode is deprecated along with isAsyncMode

var AsyncMode = REACT_ASYNC_MODE_TYPE;
var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
var ContextConsumer = REACT_CONTEXT_TYPE;
var ContextProvider = REACT_PROVIDER_TYPE;
var Element = REACT_ELEMENT_TYPE;
var ForwardRef = REACT_FORWARD_REF_TYPE;
var Fragment = REACT_FRAGMENT_TYPE;
var Lazy = REACT_LAZY_TYPE;
var Memo = REACT_MEMO_TYPE;
var Portal = REACT_PORTAL_TYPE;
var Profiler = REACT_PROFILER_TYPE;
var StrictMode = REACT_STRICT_MODE_TYPE;
var Suspense = REACT_SUSPENSE_TYPE;
var hasWarnedAboutDeprecatedIsAsyncMode = false; // AsyncMode should be deprecated

function isAsyncMode(object) {
  {
    if (!hasWarnedAboutDeprecatedIsAsyncMode) {
      hasWarnedAboutDeprecatedIsAsyncMode = true; // Using console['warn'] to evade Babel and ESLint

      console['warn']('The ReactIs.isAsyncMode() alias has been deprecated, ' + 'and will be removed in React 17+. Update your code to use ' + 'ReactIs.isConcurrentMode() instead. It has the exact same API.');
    }
  }

  return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
}
function isConcurrentMode(object) {
  return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
}
function isContextConsumer(object) {
  return typeOf(object) === REACT_CONTEXT_TYPE;
}
function isContextProvider(object) {
  return typeOf(object) === REACT_PROVIDER_TYPE;
}
function isElement(object) {
  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
}
function isForwardRef(object) {
  return typeOf(object) === REACT_FORWARD_REF_TYPE;
}
function isFragment(object) {
  return typeOf(object) === REACT_FRAGMENT_TYPE;
}
function isLazy(object) {
  return typeOf(object) === REACT_LAZY_TYPE;
}
function isMemo(object) {
  return typeOf(object) === REACT_MEMO_TYPE;
}
function isPortal(object) {
  return typeOf(object) === REACT_PORTAL_TYPE;
}
function isProfiler(object) {
  return typeOf(object) === REACT_PROFILER_TYPE;
}
function isStrictMode(object) {
  return typeOf(object) === REACT_STRICT_MODE_TYPE;
}
function isSuspense(object) {
  return typeOf(object) === REACT_SUSPENSE_TYPE;
}

exports.AsyncMode = AsyncMode;
exports.ConcurrentMode = ConcurrentMode;
exports.ContextConsumer = ContextConsumer;
exports.ContextProvider = ContextProvider;
exports.Element = Element;
exports.ForwardRef = ForwardRef;
exports.Fragment = Fragment;
exports.Lazy = Lazy;
exports.Memo = Memo;
exports.Portal = Portal;
exports.Profiler = Profiler;
exports.StrictMode = StrictMode;
exports.Suspense = Suspense;
exports.isAsyncMode = isAsyncMode;
exports.isConcurrentMode = isConcurrentMode;
exports.isContextConsumer = isContextConsumer;
exports.isContextProvider = isContextProvider;
exports.isElement = isElement;
exports.isForwardRef = isForwardRef;
exports.isFragment = isFragment;
exports.isLazy = isLazy;
exports.isMemo = isMemo;
exports.isPortal = isPortal;
exports.isProfiler = isProfiler;
exports.isStrictMode = isStrictMode;
exports.isSuspense = isSuspense;
exports.isValidElementType = isValidElementType;
exports.typeOf = typeOf;
  })();
}
});

var reactIs = createCommonjsModule(function (module) {

if (process.env.NODE_ENV === 'production') {
  module.exports = reactIs_production_min;
} else {
  module.exports = reactIs_development;
}
});

/**
 * Flatten list of react nodes removing fragments and adding keys.
 * based on: https://github.com/grrowl/react-keyed-flatten-children/blob/5d421644a449765ddd62b659946196b4b5d7b135/index.ts
 *
 * @param  children React nodes to flatten.
 * @return Flattened react nodes.
 */

function flattenChildren(children) {
  function recur(nodes) {
    var keys = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    return Children.toArray(nodes).reduce(function (acc, node, index) {
      var _get;

      var nodeKeys = keys.concat((_get = get(node, 'key')) !== null && _get !== void 0 ? _get : index);

      if (reactIs.isFragment(node)) {
        acc.push.apply(acc, _toConsumableArray(recur(node.props.children, nodeKeys)));
      } else if (isValidElement(node)) {
        acc.push(cloneElement(node, {
          key: nodeKeys.join('.')
        }));
      } else if (typeof node === 'string' || typeof node === 'number') {
        acc.push(node);
      }

      return acc;
    }, []);
  }

  return recur(children);
}

var INITIAL_INDEX$1 = -1;

function onKeyboardFocus(props, handler) {
  var isMouseDown = false;
  return {
    onFocus: function onFocus(evt) {
      var _props$onFocus;

      (_props$onFocus = props.onFocus) === null || _props$onFocus === void 0 ? void 0 : _props$onFocus.call(props, evt);

      if (!isMouseDown) {
        handler(evt);
      }
    },
    onMouseDown: function onMouseDown(evt) {
      var _props$onMouseDown;

      (_props$onMouseDown = props.onMouseDown) === null || _props$onMouseDown === void 0 ? void 0 : _props$onMouseDown.call(props, evt);
      isMouseDown = true;
    },
    onMouseUp: function onMouseUp(evt) {
      var _props$onMouseUp;

      (_props$onMouseUp = props.onMouseUp) === null || _props$onMouseUp === void 0 ? void 0 : _props$onMouseUp.call(props, evt);
      isMouseDown = false;
    }
  };
}

var isNavigableItem = function isNavigableItem(node) {
  return isComponent('ListItem')(node) && isClickable(node.props);
};
/**
 * This custom hook detects clickable list item in a list and make them navigable with the keyboard.
 *
 * @param  options See {@link Options}
 * @return See {@link Output}
 */


var useInteractiveList = function useInteractiveList(options) {
  var ref = options.ref,
      onListItemSelected = options.onListItemSelected,
      onListItemNavigated = options.onListItemNavigated;
  var items = useMemo(function () {
    return flattenChildren(options.items);
  }, [options.items]);

  var _useState = useState(INITIAL_INDEX$1),
      _useState2 = _slicedToArray(_useState, 2),
      activeItemIndex = _useState2[0],
      setActiveItemIndex = _useState2[1]; // Attach listeners to the list.


  useEffect(function () {
    var listElement = ref.current;

    if (!listElement) {
      return undefined;
    }
    /**
     * This function calculates the next index in the list to be active
     * @param  index current index
     * @param  code  key code pressed
     * @return next index
     */


    var getNextIndex = function getNextIndex(index, key) {
      switch (key) {
        case 'ArrowDown':
          return index + 1 < items.length ? index + 1 : 0;

        case 'ArrowUp':
          return index - 1 >= 0 ? index - 1 : items.length - 1;

        default:
          return INITIAL_INDEX$1;
      }
    };
    /**
     * Resets the active index to the initial state
     */


    var resetActiveIndex = function resetActiveIndex() {
      setActiveItemIndex(INITIAL_INDEX$1);
    };
    /**
     * Handles navigation with the arrows using the keyboard
     * @param evt Key event
     */


    var onArrowPressed = function onArrowPressed(evt) {
      var key = evt.key;

      if (key !== 'ArrowUp' && key !== 'ArrowDown') {
        return;
      }

      var nextIndex = activeItemIndex;
      var iterations = 0; // Move to next navigable item.

      do {
        nextIndex = getNextIndex(nextIndex, key);
        iterations += 1;
      } while (nextIndex !== INITIAL_INDEX$1 && nextIndex !== activeItemIndex && !isNavigableItem(items[nextIndex]) && iterations < items.length);

      setActiveItemIndex(nextIndex);
      evt.preventDefault();
      evt.stopPropagation();
      onListItemNavigated === null || onListItemNavigated === void 0 ? void 0 : onListItemNavigated(nextIndex, get(items, [nextIndex, 'key']));
    };
    /**
     * Reset active list item index when focusing outside the list.
     * @param evt Focus out event
     */


    var onFocusOut = function onFocusOut(evt) {
      if (!evt.relatedTarget || !listElement.contains(evt.relatedTarget)) {
        resetActiveIndex();
      }
    };

    listElement.addEventListener('focusout', onFocusOut);
    listElement.addEventListener('keydown', onArrowPressed);
    return function () {
      listElement.removeEventListener('focusout', onFocusOut);
      listElement.removeEventListener('keydown', onArrowPressed);
    };
  }, [ref, activeItemIndex, items, onListItemNavigated]);
  return useMemo(function () {
    var hasClickableItem = false;
    var transformedItems = items.map(function (item, index) {
      var _item$props$isHighlig;

      // Ignore if list not clickable or item is not a simple list item.
      if (!isNavigableItem(item)) {
        return item;
      }

      hasClickableItem = true;
      var isHighlighted = index === activeItemIndex; // Clone list item: inject ref, add tab index and active state.

      return cloneElement(item, _objectSpread2({}, item.props, {
        isHighlighted: (_item$props$isHighlig = item.props.isHighlighted) !== null && _item$props$isHighlig !== void 0 ? _item$props$isHighlig : isHighlighted,
        linkRef: mergeRefs(item.props.linkRef, function (element) {
          if (isHighlighted) {
            element === null || element === void 0 ? void 0 : element.focus();
          }
        }),
        onItemSelected: function onItemSelected(evt) {
          var _item$props$onItemSel, _item$props;

          (_item$props$onItemSel = (_item$props = item.props).onItemSelected) === null || _item$props$onItemSel === void 0 ? void 0 : _item$props$onItemSel.call(_item$props);
          onListItemSelected === null || onListItemSelected === void 0 ? void 0 : onListItemSelected(index, item.key, evt);
        }
      }, onKeyboardFocus(item.props, function () {
        setActiveItemIndex(index);
      })));
    });
    return {
      items: transformedItems,
      hasClickableItem: hasClickableItem
    };
  }, [items, activeItemIndex, onListItemSelected]);
};

/**
 * Defines the props of the component.
 */

/**
 * Component display name.
 */
var COMPONENT_NAME$1 = 'List';
/**
 * Component default class name and class prefix.
 */

var CLASSNAME$1 = getRootClassName(COMPONENT_NAME$1);
/* eslint-disable jsx-a11y/no-noninteractive-tabindex */

/**
 * List component.
 *
 * @param  props Component props.
 * @param  ref   Component ref.
 * @return React element.
 */

var InternalList = forwardRef(function (props, ref) {
  var children = props.children,
      className = props.className,
      isClickable = props.isClickable,
      itemPadding = props.itemPadding,
      onListItemSelected = props.onListItemSelected,
      forwardedProps = _objectWithoutProperties(props, ["children", "className", "isClickable", "itemPadding", "onListItemSelected"]);

  var listElementRef = useRef(null);

  var _useInteractiveList = useInteractiveList({
    items: children,
    ref: listElementRef,
    onListItemSelected: onListItemSelected
  }),
      items = _useInteractiveList.items,
      hasClickableItem = _useInteractiveList.hasClickableItem;

  var clickable = hasClickableItem || isClickable;
  return React.createElement("ul", _extends({}, forwardedProps, {
    className: classnames(className, handleBasicClasses({
      prefix: CLASSNAME$1,
      itemPadding: itemPadding !== null && itemPadding !== void 0 ? itemPadding : clickable ? Size.big : undefined
    })),
    tabIndex: clickable ? 0 : -1,
    ref: mergeRefs(ref, listElementRef)
  }), items);
});
InternalList.displayName = COMPONENT_NAME$1;
InternalList.className = CLASSNAME$1;
var List = Object.assign(InternalList, {
  useKeyboardListNavigation: useKeyboardListNavigation
});

export { List as L, ListItem as a, isClickable as i };
//# sourceMappingURL=List2.js.map
