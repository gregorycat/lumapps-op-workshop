import isBoolean from 'lodash/isBoolean';
import isEmpty from 'lodash/isEmpty';
import kebabCase from 'lodash/kebabCase';
import noop from 'lodash/noop';

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};

  var target = _objectWithoutPropertiesLoose(source, excluded);

  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

    return arr2;
  }
}

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArray(iter) {
  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
}

function _iterableToArrayLimit(arr, i) {
  if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) {
    return;
  }

  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance");
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance");
}

function createCommonjsModule(fn, basedir, module) {
	return module = {
		path: basedir,
		exports: {},
		require: function (path, base) {
			return commonjsRequire(path, (base === undefined || base === null) ? module.path : base);
		}
	}, fn(module, module.exports), module.exports;
}

function commonjsRequire () {
	throw new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');
}

var classnames = createCommonjsModule(function (module) {
/*!
  Copyright (c) 2017 Jed Watson.
  Licensed under the MIT License (MIT), see
  http://jedwatson.github.io/classnames
*/
/* global define */

(function () {

	var hasOwn = {}.hasOwnProperty;

	function classNames () {
		var classes = [];

		for (var i = 0; i < arguments.length; i++) {
			var arg = arguments[i];
			if (!arg) continue;

			var argType = typeof arg;

			if (argType === 'string' || argType === 'number') {
				classes.push(arg);
			} else if (Array.isArray(arg) && arg.length) {
				var inner = classNames.apply(null, arg);
				if (inner) {
					classes.push(inner);
				}
			} else if (argType === 'object') {
				for (var key in arg) {
					if (hasOwn.call(arg, key) && arg[key]) {
						classes.push(key);
					}
				}
			}
		}

		return classes.join(' ');
	}

	if ( module.exports) {
		classNames.default = classNames;
		module.exports = classNames;
	} else {
		window.classNames = classNames;
	}
}());
});

/**
 * Enhance isEmpty method to also works with numbers.
 *
 * @param  value The value to check.
 * @return Whether the input value is empty or != 0.
 */

var _isEmpty = function _isEmpty(value) {
  if (typeof value === 'number') {
    return value === 0;
  }

  return isEmpty(value);
};
/**
 * Get the basic CSS class for the given type.
 *
 * @param  prefix The class name prefix for the generated CSS class.
 * @param  type   The type of CSS class we want to generate (e.g.: 'color', 'variant', ...).
 * @param  value  The value of the type of the CSS class (e.g.: 'primary', 'button', ...).
 * @return The basic CSS class.
 */


function getBasicClass(_ref) {
  var prefix = _ref.prefix,
      type = _ref.type,
      value = _ref.value;

  if (isBoolean(value)) {
    if (!value) {
      // False value should not return a class.
      return '';
    }

    var booleanPrefixes = ['has', 'is'];

    if (booleanPrefixes.some(function (booleanPrefix) {
      return type.toString().startsWith(booleanPrefix);
    })) {
      return "".concat(prefix, "--").concat(kebabCase(type));
    }

    return "".concat(prefix, "--is-").concat(kebabCase(type));
  }

  return "".concat(prefix, "--").concat(kebabCase(type), "-").concat(value);
}
/**
 * Return all basic LumX CSS classes which are available for every components.
 *
 * @see {@link /src/components/index.d.ts} for the possible values of each parameter.
 *
 * @param  prefix The class name prefix for the generated CSS class.
 * @param  props  All the other props you want to generate a class.
 *                The rule of thumb: the key is the name of the prop in the class, the value a string that will
 *                be used in the classname to represent the value of the given prop.
 * @return All LumX basic CSS classes.
 */

function handleBasicClasses(_ref2) {
  var prefix = _ref2.prefix,
      props = _objectWithoutProperties(_ref2, ["prefix"]);

  var otherClasses = {};

  if (!isEmpty(props)) {
    Object.keys(props).forEach(function (prop) {
      otherClasses[getBasicClass({
        prefix: prefix,
        type: prop,
        value: props[prop]
      })] = isBoolean(props[prop]) ? props[prop] : !_isEmpty(props[prop]);
    });
  }

  return classnames(prefix, otherClasses);
}
/**
 * Checks whether or not the browser support passive events.
 * @see https://github.com/Modernizr/Modernizr/blob/6d56d814b9682843313b16060adb25a58d83a317/feature-detects/dom/passiveeventlisteners.js
 */

function isPassiveEventAvailable() {
  var supportsPassiveOption = false;

  try {
    var opts = Object.defineProperty({}, 'passive', {
      get: function get() {
        supportsPassiveOption = true;
      }
    });
    window.addEventListener('testPassiveEventSupport', noop, opts);
    window.removeEventListener('testPassiveEventSupport', noop, opts);
  } catch (e) {// ignored
  }

  return supportsPassiveOption;
}
/**
 * Detects horizontal swipe direction without blocking the browser scroll using passive event.
 * @see http://javascriptkit.com/javatutors/touchevents2.shtml
 * @see https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md
 */


function detectHorizontalSwipe(touchSurface, handleSwipe) {
  var startX;
  var startY; // Required min distance traveled to be considered swipe.

  var threshold = 150; // Maximum distance allowed at the same time in perpendicular direction.

  var restraint = 150; // Maximum time allowed to travel that distance.

  var allowedTime = 300;
  var elapsedTime;
  var startTime;
  var finished;

  var onTouchStart = function onTouchStart(evt) {
    var _Array$from5 = Array.from(evt.changedTouches),
        _Array$from6 = _slicedToArray(_Array$from5, 1),
        touch = _Array$from6[0];

    startX = touch.pageX;
    startY = touch.pageY; // Record time when finger first makes contact with surface.

    startTime = new Date().getTime();
    finished = false;
  };

  var onTouchMove = function onTouchMove(evt) {
    if (finished) {
      return;
    }

    elapsedTime = new Date().getTime() - startTime;

    if (elapsedTime > allowedTime) {
      // Touch swipe too long to be considered.
      return;
    }

    var _Array$from7 = Array.from(evt.changedTouches),
        _Array$from8 = _slicedToArray(_Array$from7, 1),
        touch = _Array$from8[0]; // Get horizontal dist traveled by finger while in contact with surface.


    var distX = touch.pageX - startX; // Get vertical dist traveled by finger while in contact with surface.

    var distY = touch.pageY - startY;

    if (!(Math.abs(distX) >= threshold && Math.abs(distY) <= restraint)) {
      // Swipe is not horizontal.
      return;
    } // Swipe direction.


    var direction = distX < 0 ? 'left' : 'right';
    handleSwipe(direction);
    finished = true;
  }; // Activate passive event if possible for better scrolling performance.


  var eventOptions = isPassiveEventAvailable() ? {
    passive: true
  } : false;
  touchSurface.addEventListener('touchstart', onTouchStart, eventOptions);
  touchSurface.addEventListener('touchmove', onTouchMove, eventOptions);
  return function () {
    touchSurface.removeEventListener('touchstart', onTouchStart, eventOptions);
    touchSurface.removeEventListener('touchmove', onTouchMove, eventOptions);
  };
}

/**
 * Make sure the pressed key is the enter key before calling the callback.
 *
 * @param  handler The handler to call on enter/return press.
 * @return The decorated function.
 */
function onEnterPressed(handler) {
  return function (evt) {
    if (evt.key !== 'Enter') {
      return;
    }

    handler(evt);
  };
}
/**
 * Make sure the pressed key is the escape key before calling the callback.
 *
 * @param  handler The handler to call on enter/return press.
 * @return The decorated function.
 */

function onEscapePressed(handler) {
  return function (evt) {
    if (evt.key !== 'Escape') {
      return;
    }

    handler(evt);
  };
}

/**
 * The prefix to use for the CSS classes.
 */
var CSS_PREFIX = 'lumx';
/**
 * Animation duration constants. Take into consideration that if you change one of these variables,
 * you need to update their scss counterpart as well
 */

var DIALOG_TRANSITION_DURATION = 400;
var NOTIFICATION_TRANSITION_DURATION = 200;

var LAST_PART_CLASSNAME = /^(.*)-(.+)$/gi;
/**
 * Get the name of the root CSS class of a component based on its name.
 *
 * @param  componentName The name of the component. This name should contains the component prefix and be
 *                       written in PascalCase.
 * @param  subComponent Whether the current component is a sub component, if true, define the class according
 *                      to BEM standards.
 * @return The name of the root CSS class. This classname include the CSS classname prefix and is written in
 *         lower-snake-case.
 */

function getRootClassName(componentName, subComponent) {
  var formattedClassName = "".concat(CSS_PREFIX, "-").concat(kebabCase(componentName));

  if (subComponent) {
    return formattedClassName.replace(LAST_PART_CLASSNAME, '$1__$2');
  }

  return formattedClassName;
}

export { CSS_PREFIX as C, DIALOG_TRANSITION_DURATION as D, NOTIFICATION_TRANSITION_DURATION as N, _defineProperty as _, _objectWithoutProperties as a, _extends as b, _objectSpread2 as c, classnames as d, getBasicClass as e, _slicedToArray as f, getRootClassName as g, handleBasicClasses as h, _toConsumableArray as i, createCommonjsModule as j, detectHorizontalSwipe as k, onEscapePressed as l, onEnterPressed as o };
//# sourceMappingURL=getRootClassName.js.map
