import { c as _objectSpread2, b as _extends, f as _slicedToArray, l as onEscapePressed, g as getRootClassName, a as _objectWithoutProperties, d as classnames, h as handleBasicClasses } from './getRootClassName.js';
import React, { useMemo, cloneElement, useRef, useState, useEffect, forwardRef } from 'react';
import { u as uid } from '../index2.js';
import { D as DOCUMENT } from './constants.js';
import get from 'lodash/get';
import { b as usePopper, P as Placement } from './Popover2.js';
import { m as mergeRefs } from './mergeRefs.js';
import { createPortal } from 'react-dom';
import pull from 'lodash/pull';
import debounce from 'lodash/debounce';

/**
 * Add ref and ARIA attribute(s) in tooltip children or wrapped children.
 * Button, IconButton, Icon and React HTML elements don't need to be wrapped but any other kind of children (array, fragment, custom components)
 * will be wrapped in a <span>.
 *
 * @param  children         Original tooltip anchor.
 * @param  setAnchorElement Set tooltip anchor element.
 * @param  isOpen           Whether the tooltip is open or not.
 * @param  id               Tooltip id.
 * @return tooltip anchor.
 */

var useInjectTooltipRef = function useInjectTooltipRef(children, setAnchorElement, isOpen, id) {
  return useMemo(function () {
    var ariaProps = {
      'aria-describedby': isOpen ? id : undefined
    };

    if (children && get(children, '$$typeof') && get(children, 'props.disabled') !== true && get(children, 'props.isDisabled') !== true) {
      var element = children;

      if (element.ref) {
        setAnchorElement(element.ref.current);
      }

      return cloneElement(element, _objectSpread2({}, element.props, {}, ariaProps, {
        ref: mergeRefs(element.ref, setAnchorElement)
      }));
    }

    return React.createElement("div", _extends({
      className: "lumx-tooltip-anchor-wrapper",
      ref: setAnchorElement
    }, ariaProps), children);
  }, [isOpen, id, children, setAnchorElement]);
};

/**
 * This singleton handle a global `mouseover` event listener on the `document` in order to toggle tooltips when
 * entering and leaving their anchor element.
 */
var tooltipMouseToggle = function () {
  /** List of tooltips to toggle on anchor enter/leave. */
  var tooltips;
  /** Global listener added on the document. */

  var globalListener;

  function addGlobalListener() {
    if (globalListener) return;
    globalListener = debounce(function (evt) {
      if (!tooltips || !evt.target) return;
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = tooltips[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var _step$value = _step.value,
              open = _step$value.open,
              close = _step$value.close,
              anchorElement = _step$value.anchorElement;

          if (anchorElement.contains(evt.target)) {
            open();
          } else {
            close();
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }, 10);
    document.addEventListener('mouseover', globalListener);
  }

  function removeGlobalListener() {
    if (!globalListener) return;
    document.removeEventListener('mouseover', globalListener);
    globalListener = undefined;
  }

  return {
    addTooltip: function addTooltip(tooltip) {
      if (!tooltips) {
        tooltips = [];
        addGlobalListener();
      }

      tooltips.push(tooltip);
    },
    removeTooltip: function removeTooltip(actions) {
      if (!tooltips) return;
      pull(tooltips, actions);

      if (tooltips.length === 0) {
        removeGlobalListener();
        tooltips = undefined;
      }
    }
  };
}();
/**
 * Hook controlling tooltip visibility using mouse hover the anchor and delay.
 *
 * @param  delay         Delay in millisecond to display the tooltip.
 * @param  anchorElement Tooltip anchor element.
 * @return whether or not to show the tooltip.
 */


function useTooltipOpen(delay, anchorElement) {
  var timer = useRef();
  var shouldOpen = useRef(false);

  var _useState = useState(false),
      _useState2 = _slicedToArray(_useState, 2),
      isOpen = _useState2[0],
      setIsOpen = _useState2[1];

  useEffect(function () {
    if (!anchorElement) {
      return undefined;
    }

    var tooltip = {
      anchorElement: anchorElement,
      open: function open() {
        if (!shouldOpen.current) {
          shouldOpen.current = true;
          timer.current = setTimeout(function () {
            setIsOpen(shouldOpen.current);
          }, delay);
        }
      },
      close: function close() {
        if (timer.current) {
          clearTimeout(timer.current);
          timer.current = undefined;
        }

        if (shouldOpen.current) {
          shouldOpen.current = false;
          setIsOpen(shouldOpen.current);
        }
      }
    };
    var keydown = onEscapePressed(tooltip.close);
    tooltipMouseToggle.addTooltip(tooltip);
    anchorElement.addEventListener('focusin', tooltip.open);
    anchorElement.addEventListener('focusout', tooltip.close);
    anchorElement.addEventListener('keydown', keydown);
    return function () {
      tooltipMouseToggle.removeTooltip(tooltip);
      anchorElement.removeEventListener('focusin', tooltip.open);
      anchorElement.removeEventListener('focusout', tooltip.close);
      anchorElement.removeEventListener('keydown', keydown);
      tooltip.close();
    };
  }, [anchorElement, delay, timer, shouldOpen]);
  return isOpen;
}

/** Position of the tooltip relative to the anchor element. */

/**
 * Component display name.
 */
var COMPONENT_NAME = 'Tooltip';
/**
 * Component default class name and class prefix.
 */

var CLASSNAME = getRootClassName(COMPONENT_NAME);
/**
 * Component default props.
 */

var DEFAULT_PROPS = {
  delay: 500,
  placement: Placement.BOTTOM
};
/**
 * Arrow size (in pixel).
 */

var ARROW_SIZE = 8;
/**
 * Tooltip component.
 *
 * @param  props Component props.
 * @param  ref   Component ref.
 * @return React element.
 */

var Tooltip = forwardRef(function (props, ref) {
  var _ref, _attributes$popper;

  if (!DOCUMENT) {
    // Can't render in SSR.
    return null;
  }

  var label = props.label,
      children = props.children,
      className = props.className,
      delay = props.delay,
      placement = props.placement,
      forceOpen = props.forceOpen,
      forwardedProps = _objectWithoutProperties(props, ["label", "children", "className", "delay", "placement", "forceOpen"]);

  if (!label) {
    return React.createElement(React.Fragment, null, children);
  }

  var id = useMemo(function () {
    return "tooltip-".concat(uid());
  }, []);

  var _useState = useState(null),
      _useState2 = _slicedToArray(_useState, 2),
      popperElement = _useState2[0],
      setPopperElement = _useState2[1];

  var _useState3 = useState(null),
      _useState4 = _slicedToArray(_useState3, 2),
      anchorElement = _useState4[0],
      setAnchorElement = _useState4[1];

  var _usePopper = usePopper(anchorElement, popperElement, {
    placement: placement,
    modifiers: [{
      name: 'offset',
      options: {
        offset: [0, ARROW_SIZE]
      }
    }]
  }),
      styles = _usePopper.styles,
      attributes = _usePopper.attributes;

  var position = (_ref = attributes === null || attributes === void 0 ? void 0 : (_attributes$popper = attributes.popper) === null || _attributes$popper === void 0 ? void 0 : _attributes$popper['data-popper-placement']) !== null && _ref !== void 0 ? _ref : placement;
  var isOpen = useTooltipOpen(delay, anchorElement) || forceOpen;
  var wrappedChildren = useInjectTooltipRef(children, setAnchorElement, isOpen, id);
  return React.createElement(React.Fragment, null, wrappedChildren, isOpen && createPortal(React.createElement("div", _extends({
    ref: mergeRefs(ref, setPopperElement)
  }, forwardedProps, {
    id: id,
    role: "tooltip",
    "aria-label": label,
    className: classnames(className, handleBasicClasses({
      prefix: CLASSNAME,
      position: position
    })),
    style: styles.popper
  }, attributes.popper), React.createElement("div", {
    className: "".concat(CLASSNAME, "__arrow")
  }), React.createElement("div", {
    className: "".concat(CLASSNAME, "__inner")
  }, label.indexOf('\n') !== -1 ? label.split('\n').map(function (sentence) {
    return React.createElement("p", {
      key: sentence
    }, sentence);
  }) : label)), document.body));
});
Tooltip.displayName = COMPONENT_NAME;
Tooltip.className = CLASSNAME;
Tooltip.defaultProps = DEFAULT_PROPS;

export { Tooltip as T };
//# sourceMappingURL=Tooltip2.js.map
