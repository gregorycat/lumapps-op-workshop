// Generated by dts-bundle-generator v5.6.0

/// <reference types="react" />

/** Get types of the values of a record. */
export declare type ValueOf<T extends Record<any, any>> = T[keyof T];
/** LumX Component Type. */
export declare type Comp<P, T = HTMLElement> = {
	(props: P & {
		ref?: Ref<T>;
	}): ReactElement | null;
	/** React component type. */
	readonly $$typeof: symbol;
	/** Component default props. */
	defaultProps?: Partial<P>;
	/** Component name. */
	displayName?: string;
	/** Component base class name. */
	className?: string;
};
/**
 * Define a generic props types.
 */
export interface GenericProps {
	/**
	 * Any prop (particularly any supported prop for a HTML element).
	 * E.g. classNames, onClick, disabled, ...
	 */
	[propName: string]: any;
}
/**
 * Callback function type alias (use for readability)
 */
export declare type Callback = () => void;
/**
 * Alignments.
 */
export declare const Alignment: {
	readonly bottom: "bottom";
	readonly center: "center";
	readonly end: "end";
	readonly left: "left";
	readonly right: "right";
	readonly spaceAround: "space-around";
	readonly spaceBetween: "space-between";
	readonly start: "start";
	readonly top: "top";
};
export declare type Alignment = ValueOf<typeof Alignment>;
export declare type VerticalAlignment = Extract<Alignment, "top" | "center" | "bottom">;
export declare type HorizontalAlignment = Extract<Alignment, "right" | "center" | "left">;
/**
 * See SCSS variable $lumx-color-palette
 */
export declare const ColorPalette: {
	readonly primary: "primary";
	readonly secondary: "secondary";
	readonly blue: "blue";
	readonly dark: "dark";
	readonly green: "green";
	readonly yellow: "yellow";
	readonly red: "red";
	readonly light: "light";
	readonly grey: "grey";
};
export declare type ColorPalette = ValueOf<typeof ColorPalette>;
export declare type Color = ColorPalette | string;
/**
 * See SCSS variable $lumx-color-variants
 */
export declare const ColorVariant: {
	readonly D1: "D1";
	readonly D2: "D2";
	readonly L1: "L1";
	readonly L2: "L2";
	readonly L3: "L3";
	readonly L4: "L4";
	readonly L5: "L5";
	readonly L6: "L6";
	readonly N: "N";
};
export declare type ColorVariant = ValueOf<typeof ColorVariant>;
export declare const Theme: {
	readonly light: "light";
	readonly dark: "dark";
};
export declare type Theme = ValueOf<typeof Theme>;
export declare const Size: {
	readonly xxs: "xxs";
	readonly xs: "xs";
	readonly s: "s";
	readonly m: "m";
	readonly l: "l";
	readonly xl: "xl";
	readonly xxl: "xxl";
	readonly tiny: "tiny";
	readonly regular: "regular";
	readonly big: "big";
	readonly huge: "huge";
};
export declare type Size = ValueOf<typeof Size>;
export declare type GlobalSize = Extract<Size, "xxs" | "xs" | "s" | "m" | "l" | "xl" | "xxl">;
export declare const Orientation: {
	readonly horizontal: "horizontal";
	readonly vertical: "vertical";
};
export declare type Orientation = ValueOf<typeof Orientation>;
export declare const Emphasis: {
	readonly low: "low";
	readonly medium: "medium";
	readonly high: "high";
};
export declare type Emphasis = ValueOf<typeof Emphasis>;
/**
 * List of typographies.
 */
export declare const Typography: {
	readonly overline: "overline";
	readonly caption: "caption";
	readonly body1: "body1";
	readonly body2: "body2";
	readonly subtitle1: "subtitle1";
	readonly subtitle2: "subtitle2";
	readonly title: "title";
	readonly headline: "headline";
	readonly display1: "display1";
};
export declare type Typography = ValueOf<typeof Typography>;
/**
 * All available aspect ratios.
 */
export declare const AspectRatio: {
	/** Intrinsic content ratio. */
	readonly original: "original";
	/** Ratio 16:9 */
	readonly wide: "wide";
	/** Ratio 3:2 */
	readonly horizontal: "horizontal";
	/** Ratio 3:2 */
	readonly vertical: "vertical";
	/** Ratio 1:1 */
	readonly square: "square";
	/** Ratio constrained by the parent. */
	readonly free: "free";
};
export declare type AspectRatio = ValueOf<typeof AspectRatio>;
/**
 * Semantic info about the purpose of the component
 */
export declare const Kind: {
	readonly info: "info";
	readonly success: "success";
	readonly warning: "warning";
	readonly error: "error";
};
export declare type Kind = ValueOf<typeof Kind>;
export interface AlertDialogProps extends Omit<DialogProps, "header" | "footer"> {
	/** Message variant. */
	kind?: Kind;
	/** Dialog title. */
	title?: string;
	/** Props forwarded to the confirm button */
	confirmProps: ButtonProps & {
		onClick(): void;
		label: string;
	};
	/**
	 * Props forwarded to the cancel button.
	 * Will not render a cancel button if undefined.
	 */
	cancelProps?: ButtonProps & {
		onClick(): void;
		label: string;
	};
}
/**
 * AlertDialog component.
 *
 * An alert dialog is a modal dialog that interrupts the user's workflow to
 * communicate an important message and acquire a response.
 *
 * It should not have a complex content.
 * Children of this component should only be strings, paragraphs or links.
 */
export declare const AlertDialog: Comp<AlertDialogProps, HTMLDivElement>;
/**
 * Defines the props of the component.
 */
export interface AutocompleteProps extends GenericProps {
	/**
	 * Whether the suggestions list should display anchored to the input or to the wrapper.
	 * @see {@link DropdownProps#anchorToInput}
	 */
	anchorToInput?: boolean;
	/**
	 * Props to pass to the clear button (minus those already set by the TextField props).
	 * If not specified, the button won't be displayed.
	 * @see {@link TextFieldProps#clearButtonProps}
	 */
	clearButtonProps?: Pick<IconButtonProps, "label"> & Omit<IconButtonProps, "label" | "onClick" | "icon" | "emphasis">;
	/**
	 * Reference to the <input> or <textarea> element.
	 * @see {@link TextFieldProps#inputRef}
	 */
	inputRef?: RefObject<HTMLInputElement>;
	/**
	 * The offset that will be applied to the Dropdown position.
	 * @see {@link DropdownProps#offset}
	 */
	offset?: Offset;
	/**
	 * The preferred Dropdown location against the anchor element.
	 * @see {@link DropdownProps#placement}
	 */
	placement?: Placement;
	/**
	 * Whether the dropdown should fit to the anchor width or not.
	 * @see {@link DropdownProps#fitToAnchorWidth}
	 */
	fitToAnchorWidth?: boolean;
	/**
	 * The error related to the component.
	 * @see {@link TextFieldProps#error}
	 */
	error?: string | ReactNode;
	/**
	 * Whether the text field is displayed with error style or not.
	 * @see {@link TextFieldProps#hasError}
	 */
	hasError?: boolean;
	/**
	 * Whether the text box should be focused upon closing the suggestions or not.
	 */
	shouldFocusOnClose?: boolean;
	/**
	 * The helper message of the text field.
	 * @see {@link TextFieldProps#helper}
	 */
	helper?: string;
	/**
	 * The icon of the text field (SVG path).
	 * @see {@link TextFieldProps#icon}
	 */
	icon?: string;
	/**
	 * Whether the component is disabled or not.
	 * @see {@link TextFieldProps#isDisabled}
	 */
	isDisabled?: boolean;
	/**
	 * Whether the component is required or not.
	 * @see {@link TextFieldProps#isRequired}
	 */
	isRequired?: boolean;
	/**
	 * Whether the text field is displayed with valid style or not.
	 * @see {@link TextFieldProps#isValid}
	 */
	isValid?: boolean;
	/**
	 * The label of the text field displayed in a label tag.
	 * @see {@link TextFieldProps#label}
	 */
	label?: string;
	/**
	 * The placeholder message of the text field.
	 * @see {@link TextFieldProps#placeholder}
	 */
	placeholder?: string;
	/** Theme adapting the component to light or dark background. */
	theme?: Theme;
	/** List of suggestions to display during autocomplete. */
	children: React.ReactNode;
	/**
	 * The list of chips to be displayed before the text field input.
	 */
	chips?: React.ReactNode;
	/**
	 * The value of the text field.
	 * @see {@link TextFieldProps#value}
	 */
	value: string;
	/**
	 * Whether the suggestions from the autocomplete should be displayed or not.
	 * @see {@link DropdownProps#isOpen}
	 */
	isOpen: boolean;
	/**
	 * The native input name property.
	 * @see {@link TextFieldProps#name}
	 */
	name?: string;
	/**
	 * Whether a click in the Autocomplete dropdown would close it or not.
	 * @see {@link DropdownProps#closeOnClick}
	 */
	closeOnClick?: boolean;
	/**
	 * Whether a click anywhere out of the Autocomplete would close it or not.
	 * @see {@link DropdownProps#closeOnClickAway}
	 */
	closeOnClickAway?: boolean;
	/**
	 * Whether an escape key press would close the Autocomplete or not.
	 * @see {@link DropdownProps#closeOnEscape}
	 */
	closeOnEscape?: boolean;
	/**
	 * The function called on blur.
	 * @see {@link TextFieldProps#onBlur}
	 */
	onBlur?(event: React.FocusEvent): void;
	/**
	 * On change callback.
	 * @see {@link TextFieldProps#onChange}
	 */
	onChange(value: string, name?: string, event?: SyntheticEvent): void;
	/**
	 * The function called on close.
	 * @see {@link DropdownProps#onClose}
	 */
	onClose?(): void;
	/**
	 * The function called on focus.
	 * @see {@link TextFieldProps#onFocus}
	 */
	onFocus?(event: React.FocusEvent): void;
	/**
	 * The function called when the bottom of the dropdown is reached.
	 * @see {@link DropdownProps#onInfiniteScroll}
	 */
	onInfiniteScroll?(): void;
}
/**
 * Autocomplete component.
 *
 * @param  props Component props.
 * @param  ref   Component ref.
 * @return React element.
 */
export declare const Autocomplete: Comp<AutocompleteProps, HTMLDivElement>;
/**
 * Defines the props of the component.
 */
export interface AutocompleteMultipleProps extends AutocompleteProps {
	/** Selected values. */
	values: any[];
	/** Alignment of the chips in the autocomplete. */
	chipsAlignment?: HorizontalAlignment;
	/** Selected value render function. Default: Renders the value inside of a Chip. */
	selectedChipRender(choice: any, index: number, onClear?: (event: React.MouseEvent, choice: any) => void, isDisabled?: boolean): ReactNode | string;
}
/**
 * AutocompleteMultiple component.
 *
 * @param  props Component props.
 * @param  ref   Component ref.
 * @return React element.
 */
export declare const AutocompleteMultiple: Comp<AutocompleteMultipleProps, HTMLDivElement>;
/**
 * Avatar sizes.
 */
export declare type AvatarSize = Extract<Size, "xs" | "s" | "m" | "l" | "xl" | "xxl">;
/**
 * Defines the props of the component.
 */
export interface AvatarProps extends GenericProps {
	/** Action toolbar content. */
	actions?: ReactNode;
	/** Image alternative text. */
	alt: string;
	/** Badge. */
	badge?: ReactElement;
	/** Image URL. */
	image: string;
	/** On click callback. */
	onClick?: MouseEventHandler<HTMLDivElement>;
	/** On key press callback. */
	onKeyPress?: KeyboardEventHandler<HTMLDivElement>;
	/** Size variant. */
	size?: AvatarSize;
	/** Theme adapting the component to light or dark background. */
	theme?: Theme;
	/** Props to pass to the thumbnail (minus those already set by the Avatar props). */
	thumbnailProps?: Omit<ThumbnailProps, "image" | "alt" | "size" | "theme" | "align" | "fillHeight" | "variant" | "aspectRatio">;
}
/**
 * Avatar component.
 *
 * @param  props Component props.
 * @param  ref   Component ref.
 * @return React element.
 */
export declare const Avatar: Comp<AvatarProps, HTMLDivElement>;
/**
 * Defines the props of the component.
 */
export interface BadgeProps extends GenericProps {
	/** Badge content. */
	children?: ReactNode;
	/** Color variant. */
	color?: Color;
}
/**
 * Badge component.
 *
 * @param  props Component props.
 * @param  ref   Component ref.
 * @return React element.
 */
export declare const Badge: Comp<BadgeProps, HTMLDivElement>;
export declare type HTMLButtonProps = DetailedHTMLProps<ButtonHTMLAttributes<HTMLButtonElement>, HTMLButtonElement>;
/**
 * Button size definition.
 */
export declare type ButtonSize = Extract<Size, "s" | "m">;
export interface BaseButtonProps extends GenericProps {
	/** ARIA button label. */
	["aria-label"]?: string;
	/** Color variant. */
	color?: Color;
	/** Emphasis variant. */
	emphasis?: Emphasis;
	/** Whether or not the button has a background color in low emphasis. */
	hasBackground?: boolean;
	/** Native anchor href property. It determines whether the Button will be a <button> or an <a>. */
	href?: string;
	/** Whether the component is disabled or not. */
	isDisabled?: boolean;
	/** Whether the component is selected or not. */
	isSelected?: boolean;
	/** Native button name property. */
	name?: string;
	/** Size variant. */
	size?: ButtonSize;
	/** Native anchor target property. */
	target?: "_self" | "_blank" | "_parent" | "_top";
	/** Theme adapting the component to light or dark background. */
	theme?: Theme;
	/** Native button type. */
	type?: HTMLButtonProps["type"];
	/** Custom react component for the link (can be used to inject react router Link). */
	linkAs?: "a" | any;
}
/**
 * Button emphasis definition.
 * @deprecated Use Emphasis instead.
 */
export declare const ButtonEmphasis: {
	readonly low: "low";
	readonly medium: "medium";
	readonly high: "high";
};
/**
 * Defines the props of the component.
 */
export interface ButtonProps extends BaseButtonProps {
	/** Button content. */
	children?: ReactNode;
	/** Left icon (SVG path). */
	leftIcon?: string;
	/** Right icon (SVG path). */
	rightIcon?: string;
}
/**
 * Button component.
 *
 * @param  props Component props.
 * @param  ref   Component ref.
 * @return React element.
 */
export declare const Button: Comp<ButtonProps, HTMLButtonElement | HTMLAnchorElement>;
/**
 * Defines the props of the component.
 */
export interface IconButtonProps extends BaseButtonProps {
	/** Icon (SVG path). */
	icon: string;
	/**
	 * Label text (required for a11y purpose).
	 * If you really don't want an aria-label, you can set an empty label (this is not recommended).
	 */
	label: string;
	/**
	 * Props to pass to the tooltip.
	 * If undefined or if tooltipProps.label is undefined, the label prop will be used as tooltip label.
	 * */
	tooltipProps?: Partial<TooltipProps>;
	/** Whether the tooltip should be hidden or not. */
	hideTooltip?: boolean;
}
/**
 * IconButton component.
 *
 * @param  props Component props.
 * @param  ref   Component ref.
 * @return React element.
 */
export declare const IconButton: Comp<IconButtonProps, HTMLButtonElement>;
/**
 * Defines the props of the component
 */
export declare type ButtonGroupProps = GenericProps;
/**
 * ButtonGroup component.
 *
 * @param  props Component props.
 * @param  ref   Component ref.
 * @return React element.
 */
export declare const ButtonGroup: Comp<ButtonGroupProps, HTMLDivElement>;
/**
 * Defines the props of the component.
 */
export interface CheckboxProps extends GenericProps {
	/** Helper text. */
	helper?: string;
	/** Native input id property. */
	id?: string;
	/** Whether it is checked or not. */
	isChecked?: boolean;
	/** Whether the component is disabled or not. */
	isDisabled?: boolean;
	/** Label text. */
	label?: ReactNode;
	/** Native input name property. */
	name?: string;
	/** Theme adapting the component to light or dark background. */
	theme?: Theme;
	/** Native input value property. */
	value?: string;
	/** On change callback. */
	onChange?(isChecked: boolean, value?: string, name?: string, event?: SyntheticEvent): void;
}
/**
 * Checkbox component.
 *
 * @param  props Component props.
 * @param  ref   Component ref.
 * @return React element.
 */
export declare const Checkbox: Comp<CheckboxProps, HTMLDivElement>;
/**
 * Chip sizes.
 */
export declare type ChipSize = Extract<Size, "s" | "m">;
/**
 * Defines the props of the component.
 */
export interface ChipProps extends GenericProps {
	/** A component to be rendered after the content. */
	after?: ReactNode;
	/** A component to be rendered before the content. */
	before?: ReactNode;
	/** Color variant. */
	color?: Color;
	/** Whether the component is clickable or not. */
	isClickable?: boolean;
	/** Whether the component is disabled or not. */
	isDisabled?: boolean;
	/** Whether the chip is currently in a highlighted state or not. */
	isHighlighted?: boolean;
	/** Whether the component is selected or not. */
	isSelected?: boolean;
	/** Size variant. */
	size?: ChipSize;
	/** Theme adapting the component to light or dark background. */
	theme?: Theme;
	/** On "after" element clicked callback. */
	onAfterClick?: MouseEventHandler;
	/** On "before" element clicked callback. */
	onBeforeClick?: MouseEventHandler;
}
/**
 * Chip component.
 *
 * @param  props Component props.
 * @param  ref   Component ref.
 * @return React element.
 */
export declare const Chip: Comp<ChipProps, HTMLAnchorElement>;
export interface UseChipGroupNavigation {
	/** the current active chip index */
	activeChip: number;
	/** callback to be executed when the backspace was pressed */
	onBackspacePressed(): void;
	/** function that allows to reset the navigation */
	resetChipNavigation(): void;
}
export declare type useChipGroupNavigationType<C = any> = (chips: C[], onChipDeleted: (chip: C) => void, initialActiveChip?: number) => UseChipGroupNavigation;
/**
 * Defines the props of the component.
 */
export interface ChipGroupProps extends GenericProps {
	/** Chip horizontal alignment. */
	align?: HorizontalAlignment;
	/** List of Chip. */
	children: ReactNode;
}
export declare const ChipGroup: Comp<ChipGroupProps, HTMLDivElement> & {
	useChipGroupNavigation: import("../../hooks/useChipGroupNavigation").useChipGroupNavigationType<any>;
};
/**
 * Comment block variants.
 */
export declare const CommentBlockVariant: {
	readonly indented: "indented";
	readonly linear: "linear";
};
export declare type CommentBlockVariant = ValueOf<typeof CommentBlockVariant>;
/**
 * Defines the props of the component.
 */
export interface CommentBlockProps extends GenericProps {
	/** Action toolbar content. */
	actions?: ReactNode;
	/** Props to pass to the avatar. */
	avatarProps: AvatarProps;
	/** Comment block replies. */
	children?: ReactNode;
	/** Comment date. */
	date: string;
	/** Whether the component has actions to display or not. */
	hasActions?: boolean;
	/** Action toolbar header content. */
	headerActions?: ReactNode;
	/** Whether the component is open or not. */
	isOpen?: boolean;
	/** Whether the comment is relevant or not. */
	isRelevant?: boolean;
	/** Comment author name. */
	name: string;
	/** On click callback. */
	onClick?(): void;
	/** On mouse enter callback. */
	onMouseEnter?(): void;
	/** On mouse leave callback. */
	onMouseLeave?(): void;
	/** Comment content. */
	text: ReactNode | string;
	/** Theme adapting the component to light or dark background. */
	theme?: Theme;
	/** Comment variant. */
	variant?: CommentBlockVariant;
}
/**
 * CommentBlock component.
 *
 * @param  props Component props.
 * @param  ref   Component ref.
 * @return React element.
 */
export declare const CommentBlock: Comp<CommentBlockProps, HTMLDivElement>;
/**
 * Defines the props of the component.
 */
export interface DatePickerProps extends GenericProps {
	/** Default month. */
	defaultMonth?: Date;
	/** Locale (language or region) to use. */
	locale: string;
	/** Date after which dates can't be selected. */
	maxDate?: Date;
	/** Date before which dates can't be selected. */
	minDate?: Date;
	/** Props to pass to the next month button (minus those already set by the DatePickerControlled props). */
	nextButtonProps: Pick<IconButtonProps, "label"> & Omit<IconButtonProps, "label" | "onClick" | "icon" | "emphasis">;
	/** Props to pass to the previous month button (minus those already set by the DatePickerControlled props). */
	previousButtonProps: Pick<IconButtonProps, "label"> & Omit<IconButtonProps, "label" | "onClick" | "icon" | "emphasis">;
	/** Reference to the <button> element corresponding to the current date or the selected date. */
	todayOrSelectedDateRef?: RefObject<HTMLButtonElement>;
	/** Currently selected date. */
	value: Date | undefined;
	/** On change callback. */
	onChange(value: Date | undefined): void;
}
/**
 * DatePicker component.
 *
 * @param  props Component props.
 * @param  ref   Component ref.
 * @return React element.
 */
export declare const DatePicker: Comp<DatePickerProps, HTMLDivElement>;
/**
 * Defines the props of the component.
 */
export interface DatePickerControlledProps extends DatePickerProps {
	/** Selected month to display. */
	selectedMonth: Date;
	/** On previous month change callback. */
	onPrevMonthChange(): void;
	/** On next month change callback. */
	onNextMonthChange(): void;
}
/**
 * DatePickerControlled component.
 *
 * @param  props Component props.
 * @param  ref   Component ref.
 * @return React element.
 */
export declare const DatePickerControlled: Comp<DatePickerControlledProps, HTMLDivElement>;
/**
 * Defines the props of the component.
 */
export interface DatePickerFieldProps extends GenericProps {
	/** Default month. */
	defaultMonth?: Date;
	/** Whether the component is disabled or not. */
	isDisabled?: boolean;
	/** Locale (language or region) to use. */
	locale: string;
	/** Date after which dates can't be selected. */
	maxDate?: Date;
	/** Date before which dates can't be selected. */
	minDate?: Date;
	/** Native input name property. */
	name?: string;
	/** Props to pass to the next month button (minus those already set by the DatePickerControlled props). */
	nextButtonProps: Pick<IconButtonProps, "label"> & Omit<IconButtonProps, "label" | "onClick" | "icon" | "emphasis">;
	/** Props to pass to the previous month button (minus those already set by the DatePickerControlled props). */
	previousButtonProps: Pick<IconButtonProps, "label"> & Omit<IconButtonProps, "label" | "onClick" | "icon" | "emphasis">;
	/** Currently selected date. */
	value: Date | undefined;
	/** On change callback. */
	onChange(value: Date | undefined, name?: string, event?: SyntheticEvent): void;
}
/**
 * DatePickerField component.
 *
 * @param  props Component props.
 * @param  ref   Component ref.
 * @return React element.
 */
export declare const DatePickerField: Comp<DatePickerFieldProps, HTMLDivElement>;
/**
 * Defines the props of the component.
 */
export interface DialogProps extends GenericProps {
	/** Footer content. */
	footer?: ReactNode;
	/** Whether the divider between the dialog content and the footer is always displayed (instead of showing it on scroll). */
	forceFooterDivider?: boolean;
	/** Header content. */
	header?: ReactNode;
	/** Whether the divider between the dialog content and the footer is always displayed (instead of showing it on scroll). */
	forceHeaderDivider?: boolean;
	/** Whether the indefinite progress indicator over the dialog content is displayed or not. */
	isLoading?: boolean;
	/** Whether the component is open or not. */
	isOpen?: boolean;
	/** Reference to the parent element that triggered modal opening (will get back focus on close). */
	parentElement?: RefObject<HTMLElement>;
	/** Reference to the dialog content element. */
	contentRef?: RefObject<HTMLDivElement>;
	/** Reference to the of the element that should get the focus when the dialogs opens. By default, the first child will take focus. */
	focusElement?: RefObject<HTMLElement>;
	/** Whether to keep the dialog open on clickaway or escape press. */
	preventAutoClose?: boolean;
	/** Size variant. */
	size?: DialogSizes;
	/** Z-axis position. */
	zIndex?: number;
	/** Z-axis position. */
	dialogProps?: GenericProps;
	/** On close callback. */
	onClose?(): void;
	/** Callback called when the open animation starts and the close animation finishes. */
	onVisibilityChange?(isVisible: boolean): void;
}
export declare type DialogSizes = Extract<Size, "tiny" | "regular" | "big" | "huge">;
/**
 * Dialog component.
 *
 * @param  props Component props.
 * @param  ref   Component ref.
 * @return React element.
 */
export declare const Dialog: Comp<DialogProps, HTMLDivElement>;
/**
 * Defines the props of the component.
 */
export interface DividerProps extends GenericProps {
	/** Theme adapting the component to light or dark background. */
	theme?: Theme;
}
/**
 * Component default props.
 */
export declare const DEFAULT_PROPS: Partial<DividerProps>;
/**
 * Divider component.
 *
 * @param  props Component props.
 * @param  ref   Component ref.
 * @return React element.
 */
export declare const Divider: Comp<DividerProps, HTMLHRElement>;
/**
 * Defines the props of the component.
 */
export interface DragHandleProps extends GenericProps {
	/** Theme adapting the component to light or dark background. */
	theme?: Theme;
}
/**
 * DragHandle component.
 *
 * @param  props Component props.
 * @param  ref   Component ref.
 * @return React element.
 */
export declare const DragHandle: Comp<DragHandleProps, HTMLDivElement>;
/**
 * Different possible placements for the popover.
 */
export declare const Placement: {
	readonly AUTO: "auto";
	readonly AUTO_END: "auto-end";
	readonly AUTO_START: "auto-start";
	readonly TOP: "top";
	readonly TOP_END: "top-end";
	readonly TOP_START: "top-start";
	readonly RIGHT: "right";
	readonly RIGHT_END: "right-end";
	readonly RIGHT_START: "right-start";
	readonly BOTTOM: "bottom";
	readonly BOTTOM_END: "bottom-end";
	readonly BOTTOM_START: "bottom-start";
	readonly LEFT: "left";
	readonly LEFT_END: "left-end";
	readonly LEFT_START: "left-start";
};
export declare type Placement = ValueOf<typeof Placement>;
/**
 * Offset of the popover.
 */
export interface Offset {
	/** Offset size along the reference. */
	along?: number;
	/** Offset size away from the reference. */
	away?: number;
}
/**
 * Popover elevation index.
 */
export declare type Elevation = 1 | 2 | 3 | 4 | 5;
/**
 * Defines the props of the component.
 */
export interface PopoverProps extends GenericProps {
	/** Reference to the DOM element used to set the position of the popover. */
	anchorRef: React.RefObject<HTMLElement>;
	/** Element which will act as boundary when opening the popover. */
	boundaryRef?: RefObject<HTMLElement>;
	/** Content. */
	children: ReactNode;
	/** Whether a click anywhere out of the popover would close it. */
	closeOnClickAway?: boolean;
	/** Whether an escape key press would close the popover. */
	closeOnEscape?: boolean;
	/** Shadow elevation. */
	elevation?: Elevation;
	/** Whether the dropdown should fit to the anchor width (if dropdown is smaller). */
	fitToAnchorWidth?: boolean;
	/** Shrink popover if even after flipping there is not enough space. */
	fitWithinViewportHeight?: boolean;
	/** Element to focus when opening the popover. */
	focusElement?: RefObject<HTMLElement>;
	/** Whether we put an arrow or not. */
	hasArrow?: boolean;
	/** Whether the popover is open or not. */
	isOpen: boolean;
	/** Offset placement relative to anchor. */
	offset?: Offset;
	/** Placement relative to anchor. */
	placement?: Placement;
	/** Whether the popover should be rendered into a DOM node that exists outside the DOM hierarchy of the parent component. */
	usePortal?: boolean;
	/** Z-axis position. */
	zIndex?: number;
	/** On close callback (on click away or Escape pressed). */
	onClose?(): void;
}
/**
 * Popover component.
 *
 * @param  props Component props.
 * @param  ref   Component ref.
 * @return React element.
 */
export declare const Popover: Comp<PopoverProps, HTMLDivElement>;
/**
 * Defines the props of the component.
 */
export interface DropdownProps extends GenericProps {
	/** Reference to the element around which the dropdown is placed.
	 * @see {@link PopoverProps#anchorRef}
	 */
	anchorRef: React.RefObject<HTMLElement>;
	/** Dropdown content. */
	children: React.ReactNode;
	/**
	 * Whether a click anywhere out of the Dropdown would close it or not.
	 * @see {@link PopoverProps#closeOnClickAway}
	 */
	closeOnClickAway?: boolean;
	/**
	 * Whether to close the Dropdown when clicking in it or not.
	 */
	closeOnClick?: boolean;
	/**
	 * Whether an escape key press would close the Dropdown or not.
	 * @see {@link PopoverProps#closeOnEscape}
	 */
	closeOnEscape?: boolean;
	/**
	 * Whether the dropdown should fit to the anchor width (if dropdown is smaller) or not.
	 * @see {@link PopoverProps#fitToAnchorWidth}
	 */
	fitToAnchorWidth?: boolean;
	/**
	 * Whether the dropdown should shrink to fit within the viewport height or not.
	 * @see {@link PopoverProps#fitWithinViewportHeight}
	 */
	fitWithinViewportHeight?: boolean;
	/**
	 * Whether the dropdown should be displayed or not. Useful to control the Dropdown from outside the component.
	 * @see {@link PopoverProps#isOpen}
	 */
	isOpen: boolean;
	/**
	 * Offset applied to the Dropdown position.
	 * @see {@link PopoverProps#offset}
	 */
	offset?: Offset;
	/**
	 * Preferred Dropdown placement against the anchor element.
	 * @see {@link PopoverProps#placement}
	 */
	placement?: Placement;
	/** Whether the focus should be set on the list when the dropdown is open or not. */
	shouldFocusOnOpen?: boolean;
	/**
	 * Z-axis position.
	 * @see {@link PopoverProps#zIndex}
	 */
	zIndex?: number;
	/**
	 * On close callback.
	 * @see {@link PopoverProps#onClose}
	 */
	onClose?(): void;
	/** On scroll end callback. */
	onInfiniteScroll?(): void;
}
/**
 * Dropdown component.
 *
 * @param  props Component props.
 * @param  ref   Component ref.
 * @return React element.
 */
export declare const Dropdown: Comp<DropdownProps, HTMLDivElement>;
/**
 * Defines the props of the component.
 */
export interface ExpansionPanelProps extends GenericProps {
	/** Whether the expansion panel has a background. */
	hasBackground?: boolean;
	/** Whether the header has a divider. */
	hasHeaderDivider?: boolean;
	/** Whether the component is open or not. */
	isOpen?: boolean;
	/** Label text (overwritten if a `<header>` is provided in the children). */
	label?: string;
	/** Theme adapting the component to light or dark background. */
	theme?: Theme;
	/** On open callback. */
	onOpen?: Callback;
	/** On close callback. */
	onClose?: Callback;
	/** Props to pass to the toggle button (minus those already set by the ExpansionPanel props). */
	toggleButtonProps: Pick<IconButtonProps, "label"> & Omit<IconButtonProps, "label" | "onClick" | "icon" | "emphasis" | "color">;
	/** On toggle open or close callback. */
	onToggleOpen?(shouldOpen: boolean): void;
}
/**
 * ExpansionPanel component.
 *
 * @param  props Component props.
 * @param  ref   Component ref.
 * @return React element.
 */
export declare const ExpansionPanel: Comp<ExpansionPanelProps, HTMLDivElement>;
export interface FlagProps extends GenericProps {
	/** Theme adapting the component to light or dark background. */
	theme?: Theme;
	/** Color of the component. */
	color?: ColorPalette;
	/** Icon to use before the label. */
	icon?: string;
	/** Text label of the flag. */
	label: string;
}
/**
 * Flag component.
 *
 * @param  props Component props.
 * @param  ref   Component ref.
 * @return React element.
 */
export declare const Flag: Comp<FlagProps, HTMLDivElement>;
export declare type MarginAutoAlignment = Extract<Alignment, "top" | "bottom" | "right" | "left">;
export declare type GapSize = Extract<Size, "regular" | "big" | "huge">;
/**
 * Defines the props of the component.
 */
export interface FlexBoxProps extends GenericProps {
	/** Children elements. */
	children?: ReactNode;
	/** Whether the "content filling space" is enabled or not. */
	fillSpace?: boolean;
	/** Gap space between flexbox items. */
	gap?: GapSize;
	/** Flex horizontal alignment. */
	hAlign?: VerticalAlignment;
	/** Whether the "auto margin" is enabled all around or not. */
	marginAuto?: MarginAutoAlignment | MarginAutoAlignment[];
	/** Whether the "content shrink" is disabled or not. */
	noShrink?: boolean;
	/** Flex direction. */
	orientation?: Orientation;
	/** Flex vertical alignment. */
	vAlign?: HorizontalAlignment;
	/** Whether the "flex wrap" is enabled or not. */
	wrap?: boolean;
}
/**
 * FlexBox component.
 *
 * @param  props Component props.
 * @param  ref   Component ref.
 * @return React element.
 */
export declare const FlexBox: Comp<FlexBoxProps, HTMLDivElement>;
export declare type GridGutterSize = Extract<Size, "regular" | "big" | "huge">;
/**
 * Defines the props of the component.
 */
export interface GridProps extends GenericProps {
	/** Orientation. */
	orientation?: Orientation;
	/** Whether the children are wrapped or not. */
	wrap?: string;
	/** Vertical alignment. */
	vAlign?: Alignment;
	/** Horizontal alignment. */
	hAlign?: Alignment;
	/** Gutter size. */
	gutter?: GridGutterSize;
}
/**
 * Grid component.
 *
 * @param  props Component props.
 * @param  ref   Component ref.
 * @return React element.
 */
export declare const Grid: Comp<GridProps, HTMLDivElement>;
export declare type Columns = "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9" | "10" | "11" | "12";
/**
 * Defines the props of the component.
 */
export interface GridItemProps extends GenericProps {
	/** Alignment. */
	align?: Alignment;
	/** Order. */
	order?: Columns;
	/** Width. */
	width?: Columns;
}
/**
 * GridItem component.
 *
 * @param  props Component props.
 * @param  ref   Component ref.
 * @return React element.
 */
export declare const GridItem: Comp<GridItemProps, HTMLDivElement>;
export declare type IconSizes = Extract<Size, "xxs" | "xs" | "s" | "m" | "l" | "xl" | "xxl">;
/**
 * Defines the props of the component.
 */
export interface IconProps extends GenericProps {
	/** Color variant. */
	color?: Color;
	/** Lightened or darkened variant of the selected icon color. */
	colorVariant?: ColorVariant;
	/** Whether the icon has a shape. */
	hasShape?: boolean;
	/**
	 * Icon (SVG path).draw code (`d` property of the `<path>` SVG element).
	 * @see {@link https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths}
	 */
	icon: string;
	/** Size variant. */
	size?: IconSizes;
	/** Theme adapting the component to light or dark background. */
	theme?: Theme;
}
/**
 * Icon component.
 *
 * @param  props Component props.
 * @param  ref   Component ref.
 * @return React element.
 */
export declare const Icon: Comp<IconProps, HTMLElement>;
/**
 *  Focal point using vertical alignment, horizontal alignment or coordinates (from -1 to 1).
 */
export declare type FocusPoint = {
	x?: number;
	y?: number;
};
/**
 * All available aspect ratios.
 * @deprecated
 */
export declare const ThumbnailAspectRatio: Record<string, AspectRatio>;
/**
 *  Thumbnail sizes.
 */
export declare type ThumbnailSize = Extract<Size, "xxs" | "xs" | "s" | "m" | "l" | "xl" | "xxl">;
/**
 * Thumbnail variants.
 */
export declare const ThumbnailVariant: {
	readonly squared: "squared";
	readonly rounded: "rounded";
};
export declare type ThumbnailVariant = ValueOf<typeof ThumbnailVariant>;
export declare type ImgHTMLProps = ImgHTMLAttributes<HTMLImageElement>;
/**
 * Defines the props of the component.
 */
export interface ThumbnailProps extends GenericProps {
	/** Alignment of the thumbnail in it's parent (requires flex parent). */
	align?: HorizontalAlignment;
	/** Image alternative text. */
	alt: string;
	/** Image aspect ratio. */
	aspectRatio?: AspectRatio;
	/** Badge. */
	badge?: ReactElement;
	/** Image cross origin resource policy. */
	crossOrigin?: ImgHTMLProps["crossOrigin"];
	/** Fallback icon (SVG path) or react node when image fails to load. */
	fallback?: string | ReactNode;
	/** Whether the thumbnail should fill it's parent size (requires flex parent) or not. */
	fillHeight?: boolean;
	/** Apply relative vertical and horizontal shift (from -1 to 1) on the image position inside the thumbnail. */
	focusPoint?: FocusPoint;
	/** Image URL. */
	image: string;
	/** Props to inject into the native <img> element. */
	imgProps?: ImgHTMLProps;
	/** Reference to the native <img> element. */
	imgRef?: Ref<HTMLImageElement>;
	/** Size variant of the component. */
	size?: ThumbnailSize;
	/** Image loading mode. */
	loading?: ImgHTMLProps["loading"];
	/** On click callback. */
	onClick?: MouseEventHandler<HTMLDivElement>;
	/** On key press callback. */
	onKeyPress?: KeyboardEventHandler<HTMLDivElement>;
	/** Theme adapting the component to light or dark background. */
	theme?: Theme;
	/** Variant of the component. */
	variant?: ThumbnailVariant;
}
/**
 * Thumbnail component.
 *
 * @param  props Component props.
 * @param  ref   Component ref.
 * @return React element.
 */
export declare const Thumbnail: Comp<ThumbnailProps>;
/**
 * Image block variants.
 */
export declare const ImageBlockCaptionPosition: {
	readonly below: "below";
	readonly over: "over";
};
export declare type ImageBlockCaptionPosition = ValueOf<typeof ImageBlockCaptionPosition>;
/**
 *  Image block sizes.
 */
export declare type ImageBlockSize = Extract<Size, "xl" | "xxl">;
/**
 * Defines the props of the component.
 */
export interface ImageBlockProps extends GenericProps {
	/** Action toolbar content. */
	actions?: ReactNode;
	/** Alignment. */
	align?: HorizontalAlignment;
	/** Image alternative text. */
	alt: string;
	/** Caption position. */
	captionPosition?: ImageBlockCaptionPosition;
	/** Caption custom CSS style. */
	captionStyle?: CSSProperties;
	/** Image description. Can be either a string, or sanitized html. */
	description?: string | {
		__html: string;
	};
	/** Whether the image has to fill its container height or not. */
	fillHeight?: boolean;
	/** Image URL. */
	image: string;
	/** Size variant. */
	size?: ImageBlockSize;
	/** Tag content. */
	tags?: ReactNode;
	/** Theme adapting the component to light or dark background. */
	theme?: Theme;
	/** Props to pass to the thumbnail (minus those already set by the ImageBlock props). */
	thumbnailProps?: Omit<ThumbnailProps, "image" | "size" | "theme" | "align" | "fillHeight">;
	/** Image title to display in the caption. */
	title?: string;
}
/**
 * ImageBlock component.
 *
 * @param  props Component props.
 * @param  ref   Component ref.
 * @return React element.
 */
export declare const ImageBlock: Comp<ImageBlockProps, HTMLDivElement>;
/**
 * Defines the props of the component.
 */
export interface InputHelperProps extends GenericProps {
	/** Helper content. */
	children: string | ReactNode;
	/** Helper variant. */
	kind?: Kind;
	/** Theme adapting the component to light or dark background. */
	theme?: Theme;
}
/**
 * InputHelper component.
 *
 * @param  props Component props.
 * @param  ref   Component ref.
 * @return React element.
 */
export declare const InputHelper: Comp<InputHelperProps, HTMLSpanElement>;
/**
 * Defines the props of the component.
 */
export interface InputLabelProps extends GenericProps {
	/** Label content. */
	children: string | ReactNode;
	/** Native htmlFor property. */
	htmlFor: string;
	/** Whether the component is required or not. */
	isRequired?: boolean;
	/** Theme adapting the component to light or dark background. */
	theme?: Theme;
}
/**
 * InputLabel component.
 *
 * @param  props Component props.
 * @param  ref   Component ref.
 * @return React element.
 */
export declare const InputLabel: Comp<InputLabelProps, HTMLLabelElement>;
/**
 * Defines the props of the component.
 */
export interface LightboxProps extends GenericProps {
	/** Props to pass to the close button (minus those already set by the Lightbox props). */
	closeButtonProps?: Pick<IconButtonProps, "label"> & Omit<IconButtonProps, "label" | "onClick" | "icon" | "emphasis" | "color">;
	/** Whether the component is open or not. */
	isOpen?: boolean;
	/** Reference to the element that triggered modal opening to set focus on. */
	parentElement: RefObject<any>;
	/** Whether to keep the dialog open on clickaway or escape press. */
	preventAutoClose?: boolean;
	/** Theme adapting the component to light or dark background. */
	theme?: Theme;
	/** Z-axis position. */
	zIndex?: number;
	/** On close callback. */
	onClose?(): void;
}
/**
 * Lightbox component.
 *
 * @param  props Component props.
 * @param  ref   Component ref.
 * @return React element.
 */
export declare const Lightbox: Comp<LightboxProps, HTMLDivElement>;
export declare type HTMLAnchorProps = React.DetailedHTMLProps<React.AnchorHTMLAttributes<HTMLAnchorElement>, HTMLAnchorElement>;
/**
 * Defines the props of the component.
 */
export interface LinkProps extends GenericProps {
	/** Color variant. */
	color?: Color;
	/** Lightened or darkened variant of the selected icon color. */
	colorVariant?: ColorVariant;
	/** Link href. */
	href?: HTMLAnchorProps["href"];
	/** Whether the component is disabled or not. */
	isDisabled?: boolean;
	/** Left icon (SVG path). */
	leftIcon?: string;
	/** Custom react component for the link (can be used to inject react router Link). */
	linkAs?: "a" | any;
	/** Right icon (SVG path). */
	rightIcon?: string;
	/** Link target. */
	target?: HTMLAnchorProps["target"];
	/** Typography variant. */
	typography?: Typography;
}
/**
 * Link component.
 *
 * @param  props Component props.
 * @param  ref   Component ref.
 * @return React element.
 */
export declare const Link: Comp<LinkProps, HTMLAnchorElement | HTMLButtonElement>;
/**
 * Defines the props of the component.
 */
export interface LinkPreviewProps extends GenericProps {
	/** Description (either a string, or sanitized html). */
	description?: string | {
		__html: string;
	};
	/** Link URL. */
	link: string;
	/** Props to pass to the link (minus those already set by the LinkPreview props). */
	linkProps?: Omit<LinkProps, "color" | "colorVariant" | "href" | "target">;
	/** Size variant. */
	size?: Extract<Size, "regular" | "big">;
	/** Theme adapting the component to light or dark background. */
	theme?: Theme;
	/** Thumbnail for the link preview. */
	thumbnailProps?: ThumbnailProps;
	/** Title. */
	title?: string;
}
/**
 * LinkPreview component.
 *
 * @param  props Component props.
 * @param  ref   Component ref.
 * @return React element.
 */
export declare const LinkPreview: Comp<LinkPreviewProps, HTMLDivElement>;
export declare type Listener = (evt: KeyboardEvent) => void;
export interface UseKeyboardListNavigationType {
	/** the current active index */
	activeItemIndex: number;
	/** callback to be used when a key is pressed. usually used with the native prop `onKeyDown` */
	onKeyboardNavigation: Listener;
	/** Resets the active index to the initial state */
	resetActiveIndex(): void;
	/** Sets the active index to a given value */
	setActiveItemIndex(value: SetStateAction<number>): void;
}
export declare type useKeyboardListNavigationType = <I>(items: I[], ref: RefObject<HTMLElement>, onListItemSelected: (itemSelected: I) => void, onListItemNavigated?: (itemSelected: I) => void, onEnterPressed?: (itemSelected: string) => void, onBackspacePressed?: Listener, keepFocusAfterSelection?: boolean, initialIndex?: number, preventTabOnEnteredValue?: boolean) => UseKeyboardListNavigationType;
/**
 * Defines the props of the component.
 */
export interface ListProps extends GenericProps {
	/** List content (should be ListItem, ListSubheader or ListDivider). */
	children: ReactNode;
	/**
	 * Whether the list items are clickable.
	 * @deprecated not needed anymore.
	 */
	isClickable?: boolean;
	/** Item padding size. */
	itemPadding?: Extract<Size, "big" | "huge">;
	/**
	 * On list item selected callback.
	 *
	 * @param key   React key of the selected item.
	 * @param index Index of the selected item among the sibling items.
	 * @param evt   Source event (either mouse or keyboard event).
	 */
	onListItemSelected?(key: Key, index: number, evt: SyntheticEvent): void;
}
export declare const List: Comp<ListProps, HTMLUListElement> & {
	useKeyboardListNavigation: import("../../hooks/useKeyboardListNavigation").useKeyboardListNavigationType;
};
export declare type ListItemSize = Extract<Size, "tiny" | "regular" | "big" | "huge">;
/**
 * Defines the props of the component.
 */
export interface ListItemProps extends GenericProps {
	/** A component to be rendered after the content. */
	after?: ReactNode;
	/** A component to be rendered before the content. */
	before?: ReactNode;
	/** Content. */
	children: string | ReactNode;
	/** Whether the list item should be highlighted or not. */
	isHighlighted?: boolean;
	/** Whether the component is selected or not. */
	isSelected?: boolean;
	/** Reference to the <li> element. */
	listItemRef?: Ref<HTMLLIElement>;
	/** Custom react component for the link (can be used to inject react router Link). */
	linkAs?: "a" | any;
	/** Props that will be passed on to the Link */
	linkProps?: React.DetailedHTMLProps<React.AnchorHTMLAttributes<HTMLAnchorElement>, HTMLAnchorElement>;
	/** Reference to the link element. */
	linkRef?: Ref<HTMLAnchorElement>;
	/** Size variant. */
	size?: ListItemSize;
	/** On selected callback. */
	onItemSelected?(evt: SyntheticEvent): void;
}
/**
 * Check if the list item is clickable.
 * @return `true` if the list item is clickable; `false` otherwise.
 */
export declare function isClickable({ linkProps, onItemSelected }: Partial<ListItemProps>): boolean;
/**
 * ListItem component.
 *
 * @param  props Component props.
 * @param  ref   Component ref.
 * @return React element.
 */
export declare const ListItem: Comp<ListItemProps, HTMLLIElement>;
/**
 * Defines the props of the component.
 */
export declare type ListDividerProps = GenericProps;
/**
 * ListDivider component.
 *
 * @param  props Component props.
 * @param  ref   Component ref.
 * @return React element.
 */
export declare const ListDivider: Comp<ListDividerProps, HTMLLIElement>;
/**
 * Defines the props of the component.
 */
export interface ListSubheaderProps extends GenericProps {
	/** Content. */
	children: string | ReactNode;
}
/**
 * ListSubheader component.
 *
 * @param  props Component props.
 * @param  ref   Component ref.
 * @return React element.
 */
export declare const ListSubheader: Comp<ListSubheaderProps, HTMLLIElement>;
/**
 * Defines the props of the component.
 */
export interface MessageProps extends GenericProps {
	/** Content. */
	children?: ReactNode;
	/** Whether the message has a background or not. */
	hasBackground?: boolean;
	/** Message variant. */
	kind?: Kind;
	/** Message custom icon SVG path. */
	icon?: string;
}
/**
 * Message component.
 *
 * @param  props Component props.
 * @param  ref   Component ref.
 * @return React element.
 */
export declare const Message: Comp<MessageProps, HTMLDivElement>;
/**
 * Defines the props of the component.
 */
export interface MosaicProps extends GenericProps {
	/** Theme adapting the component to light or dark background. */
	theme?: Theme;
	/** Thumbnails. */
	thumbnails: ThumbnailProps[];
	/** On image click callback. */
	onImageClick?(index: number): void;
}
/**
 * Mosaic component.
 *
 * @param  props Component props.
 * @param  ref   Component ref.
 * @return React element.
 */
export declare const Mosaic: Comp<MosaicProps, HTMLDivElement>;
/**
 * Defines the props of the component.
 */
export interface NotificationProps extends GenericProps {
	/** Action button label. */
	actionLabel?: string;
	/** Content. */
	content?: React.ReactNode;
	/** Whether the component is open or not. */
	isOpen?: boolean;
	/** Theme adapting the component to light or dark background. */
	theme?: Theme;
	/** Notification type. */
	type?: Kind;
	/** Z-axis position. */
	zIndex?: number;
	/** On action button click callback. */
	onActionClick?(): void;
	/** On click callback. */
	onClick?(): void;
}
/**
 * Notification component.
 *
 * @param  props Component props.
 * @param  ref   Component ref.
 * @return React element.
 */
export declare const Notification: Comp<NotificationProps, HTMLDivElement>;
/**
 * Defines the props of the component.
 */
export interface PostBlockProps extends GenericProps {
	/** Action toolbar content. */
	actions?: ReactNode;
	/** Attachment content. */
	attachments?: ReactNode;
	/** Author content. */
	author?: ReactNode;
	/** Metadata content. */
	meta?: ReactNode;
	/** Orientation. */
	orientation?: Orientation;
	/** Tag content. */
	tags?: ReactNode;
	/** Content (string, or sanitized html). */
	text?: string | {
		__html: string;
	};
	/** Theme adapting the component to light or dark background. */
	theme?: Theme;
	/** Thumbnail. */
	thumbnailProps?: ThumbnailProps;
	/** Title. */
	title: string;
	/** On click callback. */
	onClick?(): void;
}
/**
 * PostBlock component.
 *
 * @param  props Component props.
 * @param  ref   Component ref.
 * @return React element.
 */
export declare const PostBlock: Comp<PostBlockProps, HTMLDivElement>;
/**
 * Progress variants.
 */
export declare const ProgressVariant: {
	readonly linear: "linear";
	readonly circular: "circular";
};
export declare type ProgressVariant = ValueOf<typeof ProgressVariant>;
/**
 * Defines the props of the component.
 */
export interface ProgressProps extends GenericProps {
	/** Theme adapting the component to light or dark background. */
	theme?: Theme;
	/** Progress variant. */
	variant?: ProgressVariant;
}
/**
 * Progress component.
 *
 * @param  props Component props.
 * @param  ref   Component ref.
 * @return React element.
 */
export declare const Progress: Comp<ProgressProps, HTMLDivElement>;
export interface ProgressTrackerProviderProps {
	/** Active step index. */
	activeStepIndex?: number;
	/** ProgressTrackerProvider children. */
	children: ReactNode;
	/** Step panel children should not render if the step panel is hidden. */
	isLazy?: boolean;
	/** Activate tabs on focus. */
	shouldActivateOnFocus?: boolean;
	/** Step change callback. */
	onChange?(index: number): void;
}
/**
 * This component provides a context in which steps can be defined and linked to their step panel.
 *
 * It does not produce any markup so you can wrap it around any React elements and then split the ProgressTracker and ProgressTrackerPanel
 * components in the react tree.
 *
 * This works exactly as TabProvider so it uses TabProviderContext and tabs state.
 *
 * @param  props React component props.
 * @return React element.
 */
export declare const ProgressTrackerProvider: React.FC<ProgressTrackerProviderProps>;
/**
 * Defines the props of the component.
 */
export interface ProgressTrackerProps extends GenericProps {
	/** ARIA label (purpose of the set of steps). */
	["aria-label"]: string;
	/** Step list. */
	children: ReactNode;
}
/**
 * ProgressTracker component.
 *
 * Implements WAI-ARIA `tablist` role {@see https://www.w3.org/TR/wai-aria-practices-1.1/examples/tabs/tabs-1/tabs.html#rps_label}
 *
 * @param  props Component props.
 * @param  ref   Component ref.
 * @return React element.
 */
export declare const ProgressTracker: Comp<ProgressTrackerProps, HTMLDivElement>;
/**
 * Defines the props of the component.
 */
export interface ProgressTrackerStepProps extends GenericProps {
	/** Children are not supported. */
	children?: never;
	/** Whether the step should be in error state or not. */
	hasError?: boolean;
	/** Helper text. */
	helper?: string | null;
	/** Native id property. */
	id?: string;
	/** Whether the current step is active or not. */
	isActive?: boolean;
	/** Whether the current step is completed or not. */
	isComplete?: boolean;
	/** Whether the component is disabled or not. */
	isDisabled?: boolean;
	/** Label text. */
	label?: string | null;
}
/**
 * ProgressTrackerStep component.
 *
 * Implements WAI-ARIA `tab` role {@see https://www.w3.org/TR/wai-aria-practices-1.1/examples/tabs/tabs-1/tabs.html#rps_label}
 *
 * @param  props Component props.
 * @param  ref   Component ref.
 * @return React element.
 */
export declare const ProgressTrackerStep: Comp<ProgressTrackerStepProps, HTMLButtonElement>;
/**
 * Defines the props of the component.
 */
export interface ProgressTrackerStepPanelProps extends GenericProps {
	/** Native id property. */
	id?: string;
	/** Whether the step is active or not. */
	isActive?: boolean;
}
/**
 * ProgressTrackerStepPanel component.
 *
 * Implements WAI-ARIA `tabpanel` role {@see https://www.w3.org/TR/wai-aria-practices-1.1/examples/tabs/tabs-1/tabs.html#rps_label}
 *
 * @param  props Component props.
 * @param  ref   Component ref.
 * @return React element.
 */
export declare const ProgressTrackerStepPanel: Comp<ProgressTrackerStepPanelProps, HTMLDivElement>;
/**
 * Defines the props of the component.
 */
export interface RadioButtonProps extends GenericProps {
	/** Helper text. */
	helper?: string;
	/** Native input id property. */
	id?: string;
	/** Whether it is checked or not. */
	isChecked?: boolean;
	/** Whether the component is disabled or not. */
	isDisabled?: boolean;
	/** Label content. */
	label?: ReactNode;
	/** Native input name property. */
	name?: string;
	/** Theme adapting the component to light or dark background. */
	theme?: Theme;
	/** Native input value property. */
	value?: string;
	/** On change callback. */
	onChange?(value?: string, name?: string, event?: SyntheticEvent): void;
}
/**
 * RadioButton component.
 *
 * @param  props Component props.
 * @param  ref   Component ref.
 * @return React element.
 */
export declare const RadioButton: Comp<RadioButtonProps, HTMLDivElement>;
/**
 * Defines the props of the component.
 */
export interface RadioGroupProps extends GenericProps {
	/** RadioButton elements */
	children: ReactNode;
}
/**
 * RadioGroup component.
 *
 * @param  props Component props.
 * @param  ref   Component ref.
 * @return React element.
 */
export declare const RadioGroup: Comp<RadioGroupProps, HTMLDivElement>;
/**
 * Select variants.
 */
export declare const SelectVariant: {
	readonly input: "input";
	readonly chip: "chip";
};
export declare type SelectVariant = ValueOf<typeof SelectVariant>;
export interface CoreSelectProps extends GenericProps {
	/** Props to pass to the clear button (minus those already set by the Select props). If not specified, the button won't be displayed. */
	clearButtonProps?: Pick<IconButtonProps, "label"> & Omit<IconButtonProps, "label" | "onClick" | "icon" | "emphasis">;
	/** Whether the select (input variant) is displayed with error style or not. */
	hasError?: boolean;
	/** Error message. */
	error?: string | ReactNode;
	/** Helper text. */
	helper?: string;
	/** Whether the select should close on click. */
	closeOnClick?: boolean;
	/** Whether the component is disabled or not. */
	isDisabled?: boolean;
	/** Whether the component is required or not. */
	isRequired?: boolean;
	/** Whether the component is open or not. */
	isOpen?: boolean;
	/** Whether the select (input variant) is displayed with valid style or not. */
	isValid?: boolean;
	/** Label text. */
	label?: string;
	/** Placeholder input text. */
	placeholder?: string;
	/** Theme adapting the component to light or dark background. */
	theme?: Theme;
	/** Select variant. */
	variant?: SelectVariant;
	/** On clear callback. */
	onClear?(event: SyntheticEvent, value?: string): void;
	/** On blur callback. */
	onBlur?(): void;
	/** On filter text change callback (with 500ms debounce). */
	onFilter?(): void;
	/** On input click callback (can be used for dropdown toggle). */
	onInputClick?(): void;
	/** On dropdown close callback. */
	onDropdownClose?(): void;
	/** On scroll end callback. */
	onInfiniteScroll?(): void;
	/** Render value function. Default: Renders the value as a string. */
	selectedValueRender?(choice: string): ReactNode | string;
}
/** Defines the props of the component. */
export interface SelectProps extends CoreSelectProps {
	/** Selected value. */
	value: string;
}
/**
 * Select component.
 *
 * @param  props Component props.
 * @param  ref   Component ref.
 * @return React element.
 */
export declare const Select: Comp<SelectProps, HTMLDivElement>;
/** Defines the props of the component. */
export interface SelectMultipleProps extends CoreSelectProps {
	/** Selected values. */
	value: string[];
	/** Selected value render function. Default: Renders the value inside of a Chip. */
	selectedChipRender?(choice: string, index: number, onClear?: (event: SyntheticEvent, choice: string) => void, isDisabled?: boolean, theme?: any): ReactNode | string;
}
export declare const SelectMultipleField: React.FC<SelectMultipleProps>;
/**
 * SelectMultiple component.
 *
 * @param  props Component props.
 * @param  ref   Component ref.
 * @return React element.
 */
export declare const SelectMultiple: Comp<SelectMultipleProps, HTMLDivElement>;
/**
 * Defines the props of the component.
 */
export interface SideNavigationProps extends GenericProps {
	/** SideNavigationItem elements. */
	children: ReactNode;
	/** Theme adapting the component to light or dark background. */
	theme?: Theme;
}
/**
 * SideNavigation component.
 *
 * @param  props Component props.
 * @param  ref   Component ref.
 * @return React element.
 */
export declare const SideNavigation: Comp<SideNavigationProps, HTMLUListElement>;
/**
 * Defines the props of the component.
 */
export interface SideNavigationItemProps extends GenericProps {
	/** SideNavigationItem elements. */
	children?: ReactNode;
	/** Emphasis variant. */
	emphasis?: Emphasis;
	/** Label content. */
	label: string | ReactNode;
	/** Icon (SVG path). */
	icon?: string;
	/** Whether the component is open or not. */
	isOpen?: boolean;
	/** Whether the component is selected or not. */
	isSelected?: boolean;
	/** Custom react component for the link (can be used to inject react router Link). */
	linkAs?: "a" | any;
	/** Props to pass to the link (minus those already set by the SideNavigationItem props). */
	linkProps?: React.DetailedHTMLProps<React.AnchorHTMLAttributes<HTMLAnchorElement>, HTMLAnchorElement>;
	/** Props to pass to the toggle button (minus those already set by the SideNavigationItem props). */
	toggleButtonProps: Pick<IconButtonProps, "label"> & Omit<IconButtonProps, "label" | "onClick" | "icon" | "emphasis" | "color" | "size">;
	/** On action button click callback. */
	onActionClick?(evt: React.MouseEvent): void;
	/** On click callback. */
	onClick?(evt: React.MouseEvent): void;
}
/**
 * SideNavigationItem component.
 *
 * @param  props Component props.
 * @param  ref   Component ref.
 * @return React element.
 */
export declare const SideNavigationItem: Comp<SideNavigationItemProps, HTMLLIElement>;
/**
 * Defines the props of the component.
 */
export interface SkeletonCircleProps extends GenericProps {
	/** Size variant. */
	size: GlobalSize;
	/** Theme. */
	theme?: Theme;
}
/**
 * SkeletonCircle component.
 *
 * @param  props Component props.
 * @param  ref   Component ref.
 * @return React element.
 */
export declare const SkeletonCircle: Comp<SkeletonCircleProps, HTMLDivElement>;
/**
 * Skeleton variants.
 */
export declare const SkeletonRectangleVariant: {
	readonly squared: "squared";
	readonly rounded: "rounded";
	readonly pill: "pill";
};
export declare type SkeletonRectangleVariant = ValueOf<typeof SkeletonRectangleVariant>;
/**
 * Defines the props of the component.
 */
export interface SkeletonRectangleProps extends GenericProps {
	/** Aspect ratio (use with width and not height). */
	aspectRatio?: Extract<AspectRatio, "square" | "horizontal" | "vertical" | "wide">;
	/** Height size. */
	height?: GlobalSize;
	/** Theme adapting the component to light or dark background. */
	theme?: Theme;
	/** Border variant. */
	variant?: SkeletonRectangleVariant;
	/** Width size. */
	width?: GlobalSize;
}
/**
 * SkeletonRectangle component.
 *
 * @param  props Component props.
 * @param  ref   Component ref.
 * @return React element.
 */
export declare const SkeletonRectangle: Comp<SkeletonRectangleProps, HTMLDivElement>;
/**
 * Defines the props of the component.
 */
export interface SkeletonTypographyProps extends GenericProps {
	/** Theme adapting the component to light or dark background. */
	theme?: Theme;
	/** Typography variant. */
	typography: Typography;
	/** Width CSS property. */
	width?: CSSProperties["width"];
}
/**
 * SkeletonTypography component.
 *
 * @param  props Component props.
 * @param  ref   Component ref.
 * @return React element.
 */
export declare const SkeletonTypography: Comp<SkeletonTypographyProps, HTMLDivElement>;
/**
 * Defines the props of the component.
 */
export interface SliderProps extends GenericProps {
	/** Helper text. */
	helper?: string;
	/** Whether the min and max labels should be hidden or not. */
	hideMinMaxLabel?: boolean;
	/** Whether the component is disabled or not. */
	isDisabled?: boolean;
	/** Label text. */
	label?: string;
	/** Maximum value on the range. */
	max: number;
	/** Minimum value of the range. */
	min: number;
	/** Native input name property. */
	name?: string;
	/** Number of digits in the fractional part of the selected value. */
	precision?: number;
	/** Range step value. */
	steps?: number;
	/** Theme adapting the component to light or dark background. */
	theme?: Theme;
	/** Selected ranged value. */
	value: number;
	/** On change callback. */
	onChange(value: number, name?: string, event?: SyntheticEvent): void;
	/** On click callback. */
	onMouseDown?(event: React.SyntheticEvent): void;
}
/**
 * Slider component.
 *
 * @param  props Component props.
 * @param  ref   Component ref.
 * @return React element.
 */
export declare const Slider: Comp<SliderProps, HTMLDivElement>;
/**
 * Clamp value in range.
 *
 * @param value Value to clamp.
 * @param min   Minimum value.
 * @param max   Maximum value.
 * @return Clamped value.
 */
export declare const clamp: (value: number, min: number, max: number) => number;
/**
 * Defines the props of the component.
 */
export interface SlideshowProps extends GenericProps {
	/** Index of the current slide. */
	activeIndex?: number;
	/** Whether the automatic rotation of the slideshow is enabled or not. */
	autoPlay?: boolean;
	/** Whether the image has to fill its container height or not. */
	fillHeight?: boolean;
	/** Number of slides to group together. */
	groupBy?: number;
	/** Interval between each slide when automatic rotation is enabled. */
	interval?: number;
	/** Props to pass to the slideshow controls (minus those already set by the Slideshow props). */
	slideshowControlsProps?: Pick<SlideshowControlsProps, "nextButtonProps" | "previousButtonProps"> & Omit<SlideshowControlsProps, "activeIndex" | "onPaginationClick" | "onNextClick" | "onPreviousClick" | "slidesCount" | "parentRef" | "theme">;
	/** Theme adapting the component to light or dark background. */
	theme?: Theme;
	/** Callback when slide changes */
	onChange?(index: number): void;
}
/**
 * Slideshow component.
 *
 * @param  props Component props.
 * @param  ref   Component ref.
 * @return React element.
 */
export declare const Slideshow: Comp<SlideshowProps, HTMLDivElement>;
/**
 * Defines the props of the component.
 */
export declare type SlideshowItemProps = GenericProps;
/**
 * SlideshowItem component.
 *
 * @param  props Component props.
 * @param  ref   Component ref.
 * @return React element.
 */
export declare const SlideshowItem: Comp<SlideshowItemProps, HTMLDivElement>;
/**
 * Defines the props of the component.
 */
export interface SlideshowControlsProps extends GenericProps {
	/** Index of the current slide. */
	activeIndex?: number;
	/** Props to pass to the next button (minus those already set by the SlideshowControls props). */
	nextButtonProps: Pick<IconButtonProps, "label"> & Omit<IconButtonProps, "label" | "onClick" | "icon" | "emphasis" | "color">;
	/** Reference to the parent element on which we want to listen touch swipe. */
	parentRef?: RefObject<HTMLDivElement> | HTMLDivElement;
	/** Props to pass to the previous button (minus those already set by the SlideshowControls props). */
	previousButtonProps: Pick<IconButtonProps, "label"> & Omit<IconButtonProps, "label" | "onClick" | "icon" | "emphasis" | "color">;
	/** Number of slides. */
	slidesCount: number;
	/** Theme adapting the component to light or dark background. */
	theme?: Theme;
	/** On next button click callback. */
	onNextClick?(loopback?: boolean): void;
	/** On pagination change callback. */
	onPaginationClick?(index: number): void;
	/** On previous button click callback. */
	onPreviousClick?(loopback?: boolean): void;
}
/**
 * SlideshowControls component.
 *
 * @param  props Component props.
 * @param  ref   Component ref.
 * @return React element.
 */
export declare const SlideshowControls: Comp<SlideshowControlsProps, HTMLDivElement>;
/**
 * Defines the props of the component.
 */
export interface SwitchProps extends GenericProps {
	/** Helper text. */
	helper?: string;
	/** Whether it is checked or not. */
	isChecked?: boolean;
	/** Whether the component is disabled or not. */
	isDisabled?: boolean;
	/** Native input name property. */
	name?: string;
	/** Position of the switch relative to the label. */
	position?: Extract<Alignment, "right" | "left">;
	/** Theme adapting the component to light or dark background. */
	theme?: Theme;
	/** Native input value property. */
	value?: string;
	/** On change callback. */
	onChange?(isChecked: boolean, value?: string, name?: string, event?: SyntheticEvent): void;
}
/**
 * Switch component.
 *
 * @param  props Component props.
 * @param  ref   Component ref.
 * @return React element.
 */
export declare const Switch: Comp<SwitchProps, HTMLDivElement>;
/**
 * Defines the props of the component.
 */
export interface TableProps extends GenericProps {
	/** Whether the table has checkbox or thumbnail on first cell or not. */
	hasBefore?: boolean;
	/** Whether the table has dividers or not. */
	hasDividers?: boolean;
	/** Theme adapting the component to light or dark background. */
	theme?: Theme;
}
/**
 * Table component.
 *
 * @param  props Component props.
 * @param  ref   Component ref.
 * @return React element.
 */
export declare const Table: Comp<TableProps, HTMLTableElement>;
/**
 * Defines the props of the component.
 */
export declare type TableBodyProps = GenericProps;
/**
 * TableBody component.
 *
 * @param  props Component props.
 * @param  ref   Component ref.
 * @return React element.
 */
export declare const TableBody: Comp<TableBodyProps, HTMLTableSectionElement>;
/**
 * Table head cell sort order.
 */
export declare const ThOrder: {
	readonly asc: "asc";
	readonly desc: "desc";
};
export declare type ThOrder = ValueOf<typeof ThOrder>;
/**
 * Table cell variants.
 */
export declare const TableCellVariant: {
	readonly body: "body";
	readonly head: "head";
};
export declare type TableCellVariant = ValueOf<typeof TableCellVariant>;
/**
 * Defines the props of the component.
 */
export interface TableCellProps extends GenericProps {
	/** Icon (SVG path).(thead only). */
	icon?: string;
	/** Whether the column is sortable or not (thead only). */
	isSortable?: boolean;
	/** Sort order displayed as icon (sortable thead only). */
	sortOrder?: ThOrder;
	/** Variant. */
	variant?: TableCellVariant;
	/** On header cell click callback. */
	onHeaderClick?(): void;
}
/**
 * TableCell component.
 *
 * @param  props Component props.
 * @param  ref   Component ref.
 * @return React element.
 */
export declare const TableCell: Comp<TableCellProps, HTMLTableCellElement>;
/**
 * Defines the props of the component.
 */
export declare type TableHeaderProps = GenericProps;
/**
 * TableHeader component.
 *
 * @param  props Component props.
 * @param  ref   Component ref.
 * @return React element.
 */
export declare const TableHeader: Comp<TableHeaderProps, HTMLTableSectionElement>;
/**
 * Defines the props of the component.
 */
export interface TableRowProps extends GenericProps {
	/** Whether the component is clickable or not. */
	isClickable?: boolean;
	/** Whether the component is disabled or not. */
	isDisabled?: boolean;
	/** Whether the component is selected or not. */
	isSelected?: boolean;
}
/**
 * TableRow component.
 *
 * @param  props Component props.
 * @param  ref   Component ref.
 * @return React element.
 */
export declare const TableRow: Comp<TableRowProps, HTMLTableRowElement>;
export interface TabProviderProps {
	/** Active tab index. */
	activeTabIndex?: number;
	/** Tab provider children. */
	children: ReactNode;
	/** Tab panel children should not render if the tab panel is hidden. */
	isLazy?: boolean;
	/** Activate tabs on focus. */
	shouldActivateOnFocus?: boolean;
	/** Tab change callback. */
	onChange?(index: number): void;
}
/**
 * This component provides a context in which tabs can be defined and linked to their tab panel.
 *
 * It does not produce any markup so you can wrap it around any React elements and then split the TabList and TabPanel
 * components in the react tree.
 *
 * @param  props React component props.
 * @return React element.
 */
export declare const TabProvider: React.FC<TabProviderProps>;
export declare enum TabListLayout {
	clustered = "clustered",
	fixed = "fixed"
}
/**
 * Defines the props of the component.
 */
export interface TabListProps extends GenericProps {
	/** ARIA label (purpose of the set of tabs). */
	["aria-label"]: string;
	/** Tab list. */
	children: ReactNode;
	/** Layout of the tabs in the list. */
	layout?: TabListLayout;
	/** Position of the tabs in the list (requires 'clustered' layout). */
	position?: Alignment;
	/** Theme adapting the component to light or dark background. */
	theme?: Theme;
}
/**
 * TabList component.
 *
 * Implements WAI-ARIA `tablist` role {@see https://www.w3.org/TR/wai-aria-practices-1.1/examples/tabs/tabs-1/tabs.html#rps_label}
 *
 * @param  props Component props.
 * @param  ref   Component ref.
 * @return React element.
 */
export declare const TabList: Comp<TabListProps, HTMLDivElement>;
/**
 * Defines the props of the component.
 */
export interface TabProps extends GenericProps {
	/** Children are not supported. */
	children?: never;
	/** Icon (SVG path). */
	icon?: IconProps["icon"];
	/** Native id property. */
	id?: string;
	/** Whether the tab is active or not. */
	isActive?: boolean;
	/** Whether the component is disabled or not. */
	isDisabled?: boolean;
	/** Label content. */
	label: string | ReactNode;
}
/**
 * Tab component.
 *
 * Implements WAI-ARIA `tab` role {@see https://www.w3.org/TR/wai-aria-practices-1.1/examples/tabs/tabs-1/tabs.html#rps_label}
 *
 * @param  props Component props.
 * @param  ref   Component ref.
 * @return React element.
 */
export declare const Tab: Comp<TabProps, HTMLButtonElement>;
/**
 * Defines the props of the component.
 */
export interface TabPanelProps extends GenericProps {
	/** Native id property */
	id?: string;
	/** Whether the tab is active or not. */
	isActive?: boolean;
}
/**
 * TabPanel component.
 *
 * Implements WAI-ARIA `tabpanel` role {@see https://www.w3.org/TR/wai-aria-practices-1.1/examples/tabs/tabs-1/tabs.html#rps_label}
 *
 * @param  props Component props.
 * @param  ref   Component ref.
 * @return React element.
 */
export declare const TabPanel: Comp<TabPanelProps, HTMLDivElement>;
/**
 * Defines the props of the component.
 */
export interface TextFieldProps extends GenericProps {
	/** Chip Group to be rendered before the main text input. */
	chips?: HTMLElement | ReactNode;
	/** Props to pass to the clear button (minus those already set by the TextField props). If not specified, the button won't be displayed. */
	clearButtonProps?: Pick<IconButtonProps, "label"> & Omit<IconButtonProps, "label" | "onClick" | "icon" | "emphasis">;
	/** Error message. */
	error?: string | ReactNode;
	/** Whether we force the focus style or not. */
	forceFocusStyle?: boolean;
	/** Whether the text field is displayed with error style or not. */
	hasError?: boolean;
	/** Helper text. */
	helper?: string | ReactNode;
	/** Icon (SVG path). */
	icon?: string;
	/** Native input id property (generated if not provided to link the label element). */
	id?: string;
	/** Reference to the <input> or <textarea> element. */
	inputRef?: RefObject<HTMLInputElement> | RefObject<HTMLTextAreaElement>;
	/** Whether the component is disabled or not. */
	isDisabled?: boolean;
	/** Whether the component is required or not. */
	isRequired?: boolean;
	/** Whether the text field is displayed with valid style or not. */
	isValid?: boolean;
	/** Label text. */
	label?: string;
	/** Max string length the input accepts (constrains the input and displays a character counter). */
	maxLength?: number;
	/** Minimum number of rows displayed in multiline mode (requires `multiline` to be enabled). */
	minimumRows?: number;
	/** Whether the text field is a textarea or an input. */
	multiline?: boolean;
	/** Native input name property. */
	name?: string;
	/** Placeholder text. */
	placeholder?: string;
	/** Reference to the wrapper. */
	textFieldRef?: RefObject<HTMLDivElement>;
	/** Theme adapting the component to light or dark background. */
	theme?: Theme;
	/** Value. */
	value?: string;
	/** On blur callback. */
	onBlur?(event: React.FocusEvent): void;
	/** On change callback. */
	onChange(value: string, name?: string, event?: SyntheticEvent): void;
	/** On focus callback. */
	onFocus?(event: React.FocusEvent): void;
}
/**
 * TextField component.
 *
 * @param  props Component props.
 * @param  ref   Component ref.
 * @return React element.
 */
export declare const TextField: Comp<TextFieldProps, HTMLDivElement>;
/**
 * Defines the props of the component.
 */
export interface ToolbarProps extends GenericProps {
	/** After content (placed after the label). */
	after?: ReactNode;
	/** Before content (placed before the label). */
	before?: ReactNode;
	/** Label content. */
	label?: ReactNode;
}
/**
 * Toolbar component.
 *
 * @param  props Component props.
 * @param  ref   Component ref.
 * @return React element.
 */
export declare const Toolbar: Comp<ToolbarProps, HTMLDivElement>;
/** Position of the tooltip relative to the anchor element. */
export declare type TooltipPlacement = Extract<Placement, "top" | "right" | "bottom" | "left">;
/**
 * Defines the props of the component.
 */
export interface TooltipProps extends GenericProps {
	/** Anchor (element on which we activate the tooltip). */
	children: ReactNode;
	/** Delay (in ms) before closing the tooltip. */
	delay?: number;
	/** Whether the tooltip is displayed even without the mouse hovering the anchor. */
	forceOpen?: boolean;
	/** Label text. */
	label?: string | null | false;
	/** Placement of the tooltip relative to the anchor. */
	placement?: TooltipPlacement;
}
/**
 * Tooltip component.
 *
 * @param  props Component props.
 * @param  ref   Component ref.
 * @return React element.
 */
export declare const Tooltip: Comp<TooltipProps, HTMLDivElement>;
/**
 * Uploader variants.
 */
export declare const UploaderVariant: {
	readonly square: "square";
	readonly rounded: "rounded";
	readonly circle: "circle";
};
export declare type UploaderVariant = ValueOf<typeof UploaderVariant>;
/**
 * Uploader sizes.
 */
export declare type UploaderSize = Extract<Size, "xl" | "xxl">;
/**
 * Defines the props of the component.
 */
export interface UploaderProps extends GenericProps {
	/** Image aspect ratio. */
	aspectRatio?: AspectRatio;
	/** Icon (SVG path). */
	icon?: string;
	/** Label text. */
	label?: string;
	/** Size variant. */
	size?: UploaderSize;
	/** Theme adapting the component to light or dark background. */
	theme?: Theme;
	/** Variant. */
	variant?: UploaderVariant;
	/** On click callback. */
	onClick?: MouseEventHandler<HTMLDivElement>;
}
/**
 * Uploader component.
 *
 * @param  props Component props.
 * @param  ref   Component ref.
 * @return React element.
 */
export declare const Uploader: Comp<UploaderProps, HTMLDivElement>;
/**
 * User block sizes.
 */
export declare type UserBlockSize = Extract<Size, "s" | "m" | "l">;
/**
 * Defines the props of the component.
 */
export interface UserBlockProps extends GenericProps {
	/** Props to pass to the avatar. */
	avatarProps?: AvatarProps;
	/** Simple action toolbar content. */
	simpleAction?: ReactNode;
	/** Multiple action toolbar content. */
	multipleActions?: ReactNode;
	/** Additional fields used to describe the user. */
	fields?: string[];
	/** User name. */
	name?: string;
	/** Orientation. */
	orientation?: Orientation;
	/** Size variant. */
	size?: UserBlockSize;
	/** Theme adapting the component to light or dark background. */
	theme?: Theme;
	/** On click callback. */
	onClick?(): void;
	/** On mouse enter callback. */
	onMouseEnter?(): void;
	/** On mouse leave callback. */
	onMouseLeave?(): void;
}
/**
 * UserBlock component.
 *
 * @param  props Component props.
 * @param  ref   Component ref.
 * @return React element.
 */
export declare const UserBlock: Comp<UserBlockProps, HTMLDivElement>;

export {};
