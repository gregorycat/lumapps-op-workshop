{"ast":null,"code":"import { f as _slicedToArray } from './getRootClassName.js';\nimport { useState, useEffect, useRef } from 'react';\n/**\n * Returns true if the component is visible taking into account the component's\n * own visibility and the animations delay\n *\n * @param isComponentVisible Whether the component intends to be visible or not.\n * @param transitionDuration time in ms that the transition takes for the specific component.\n * @param onVisibilityChange Callback called when the visibility changes.\n * @return true if the component should be rendered\n */\n\nfunction useDelayedVisibility(isComponentVisible, transitionDuration, onVisibilityChange) {\n  // Delay visibility to account for the 400ms of CSS opacity animation.\n  var _useState = useState(isComponentVisible),\n      _useState2 = _slicedToArray(_useState, 2),\n      isVisible = _useState2[0],\n      setVisible = _useState2[1];\n\n  useEffect(function () {\n    if (isComponentVisible) {\n      setVisible(true);\n    } else {\n      setTimeout(function () {\n        return setVisible(false);\n      }, transitionDuration);\n    }\n  }, [isComponentVisible, transitionDuration]);\n  /**\n   * Since we don't want onVisibiltyChange function to trigger itself if when it changes,\n   * we store the previous visibility and only trigger when visibility is different\n   * than previous value.\n   */\n\n  var previousVisibility = useRef(isVisible);\n  useEffect(function () {\n    if (onVisibilityChange && previousVisibility.current !== isVisible) {\n      onVisibilityChange(isVisible);\n      previousVisibility.current = isVisible;\n    }\n  }, [isVisible, onVisibilityChange]);\n  return isComponentVisible || isVisible;\n}\n\nexport { useDelayedVisibility as u };","map":{"version":3,"sources":["../../../src/hooks/useDelayedVisibility.tsx"],"names":["isVisible","setVisible","useState","useEffect","setTimeout","previousVisibility","useRef","onVisibilityChange","isComponentVisible"],"mappings":";;AAEA;;;;;;;;;;AASO,SAAA,oBAAA,CAAA,kBAAA,EAAA,kBAAA,EAAA,kBAAA,EAII;AACP;AADO,MAAA,SAAA,GAEyBE,QAAQ,CAFjC,kBAEiC,CAFjC;AAAA,MAAA,UAAA,GAAA,cAAA,CAAA,SAAA,EAAA,CAAA,CAAA;AAAA,MAEAF,SAFA,GAAA,UAAA,CAAA,CAAA,CAAA;AAAA,MAEWC,UAFX,GAAA,UAAA,CAAA,CAAA,CAAA;;AAIPE,EAAAA,SAAS,CAAC,YAAM;AACZ,QAAA,kBAAA,EAAwB;AACpBF,MAAAA,UAAU,CAAVA,IAAU,CAAVA;AADJ,KAAA,MAEO;AACHG,MAAAA,UAAU,CAAC,YAAA;AAAA,eAAMH,UAAU,CAAhB,KAAgB,CAAhB;AAAD,OAAA,EAAVG,kBAAU,CAAVA;AACH;AALI,GAAA,EAMN,CAAA,kBAAA,EANHD,kBAMG,CANM,CAATA;AAQA;;;;;;AAMA,MAAME,kBAAkB,GAAGC,MAAM,CAAjC,SAAiC,CAAjC;AAEAH,EAAAA,SAAS,CAAC,YAAM;AACZ,QAAII,kBAAkB,IAAIF,kBAAkB,CAAlBA,OAAAA,KAA1B,SAAA,EAAoE;AAChEE,MAAAA,kBAAkB,CAAlBA,SAAkB,CAAlBA;AACAF,MAAAA,kBAAkB,CAAlBA,OAAAA,GAAAA,SAAAA;AACH;AAJI,GAAA,EAKN,CAAA,SAAA,EALHF,kBAKG,CALM,CAATA;AAOA,SAAOK,kBAAkB,IAAzB,SAAA;AACH","sourcesContent":["import { useEffect, useState, useRef } from 'react';\n\n/**\n * Returns true if the component is visible taking into account the component's\n * own visibility and the animations delay\n *\n * @param isComponentVisible Whether the component intends to be visible or not.\n * @param transitionDuration time in ms that the transition takes for the specific component.\n * @param onVisibilityChange Callback called when the visibility changes.\n * @return true if the component should be rendered\n */\nexport function useDelayedVisibility(\n    isComponentVisible: boolean,\n    transitionDuration: number,\n    onVisibilityChange?: (isVisible: boolean) => void,\n): boolean {\n    // Delay visibility to account for the 400ms of CSS opacity animation.\n    const [isVisible, setVisible] = useState(isComponentVisible);\n\n    useEffect(() => {\n        if (isComponentVisible) {\n            setVisible(true);\n        } else {\n            setTimeout(() => setVisible(false), transitionDuration);\n        }\n    }, [isComponentVisible, transitionDuration]);\n\n    /**\n     * Since we don't want onVisibiltyChange function to trigger itself if when it changes,\n     * we store the previous visibility and only trigger when visibility is different\n     * than previous value.\n     */\n\n    const previousVisibility = useRef(isVisible);\n\n    useEffect(() => {\n        if (onVisibilityChange && previousVisibility.current !== isVisible) {\n            onVisibilityChange(isVisible);\n            previousVisibility.current = isVisible;\n        }\n    }, [isVisible, onVisibilityChange]);\n\n    return isComponentVisible || isVisible;\n}\n"]},"metadata":{},"sourceType":"module"}