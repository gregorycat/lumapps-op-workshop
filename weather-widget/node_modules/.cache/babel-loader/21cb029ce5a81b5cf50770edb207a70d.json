{"ast":null,"code":"import { i as _toConsumableArray, c as _objectSpread2, _ as _defineProperty, f as _slicedToArray } from './getRootClassName.js';\nimport { createContext, useContext, useMemo, useEffect, useCallback } from 'react';\nimport { u as uid } from '../index2.js';\nvar INIT_STATE = {\n  isLazy: true,\n  shouldActivateOnFocus: false,\n  activeTabIndex: 0,\n  ids: {\n    tab: [],\n    tabPanel: []\n  }\n};\n\nvar reducer = function reducer(state, action) {\n  switch (action.type) {\n    case 'update':\n      return _objectSpread2({}, state, {}, action.payload);\n\n    case 'setActiveTabIndex':\n      {\n        if (state.activeTabIndex === action.payload) {\n          return state;\n        } // Change active tab index.\n\n\n        return _objectSpread2({}, state, {\n          activeTabIndex: action.payload\n        });\n      }\n\n    case 'register':\n      {\n        var _action$payload = action.payload,\n            type = _action$payload.type,\n            id = _action$payload.id; // Append tab/tabPanel id in state.\n\n        return _objectSpread2({}, state, {\n          ids: _objectSpread2({}, state.ids, _defineProperty({}, type, [].concat(_toConsumableArray(state.ids[type]), [id])))\n        });\n      }\n\n    case 'unregister':\n      {\n        var _action$payload2 = action.payload,\n            _type = _action$payload2.type,\n            _id = _action$payload2.id;\n\n        var index = state.ids[_type].indexOf(_id);\n\n        if (index === -1) return state; // Remove tab & tab panel at index.\n\n        var tabIds = _toConsumableArray(state.ids.tab);\n\n        tabIds.splice(index, 1);\n\n        var tabPanelIds = _toConsumableArray(state.ids.tabPanel);\n\n        tabPanelIds.splice(index, 1);\n        return _objectSpread2({}, state, {\n          ids: {\n            tab: tabIds,\n            tabPanel: tabPanelIds\n          }\n        });\n      }\n\n    default:\n      return state;\n  }\n};\n\nvar TabProviderContext = createContext(null);\n/* eslint-disable react-hooks/rules-of-hooks */\n\nvar useTabProviderContext = function useTabProviderContext(type, originalId) {\n  var context = useContext(TabProviderContext);\n\n  if (!context) {\n    return undefined;\n  }\n\n  var _context = _slicedToArray(context, 2),\n      state = _context[0],\n      dispatch = _context[1]; // Current tab or tab panel id.\n\n\n  var id = useMemo(function () {\n    return originalId || \"\".concat(type, \"-\").concat(uid());\n  }, // eslint-disable-next-line react-hooks/exhaustive-deps\n  []);\n  useEffect(function () {\n    // On mount: register tab or tab panel id.\n    dispatch({\n      type: 'register',\n      payload: {\n        type: type,\n        id: id\n      }\n    });\n    return function () {\n      // On unmount: unregister tab or tab panel id.\n      dispatch({\n        type: 'unregister',\n        payload: {\n          type: type,\n          id: id\n        }\n      });\n    };\n  }, // eslint-disable-next-line react-hooks/exhaustive-deps\n  []); // Find tab/tabPanel index using it's id.\n\n  var index = useMemo(function () {\n    return state.ids[type].indexOf(id);\n  }, [state.ids, type, id]);\n  var tabId = useMemo(function () {\n    return state.ids.tab[index] || '';\n  }, [state, index]);\n  var tabPanelId = useMemo(function () {\n    return state.ids.tabPanel[index] || '';\n  }, [state, index]);\n  var isActive = useMemo(function () {\n    return state.activeTabIndex === index;\n  }, [state, index]);\n  var changeToTab = useCallback(function () {\n    return dispatch({\n      type: 'setActiveTabIndex',\n      payload: index\n    });\n  }, [dispatch, index]);\n  return {\n    isLazy: state.isLazy,\n    shouldActivateOnFocus: state.shouldActivateOnFocus,\n    tabId: tabId,\n    tabPanelId: tabPanelId,\n    isActive: isActive,\n    changeToTab: changeToTab\n  };\n};\n\nvar useTabProviderContextState = function useTabProviderContextState() {\n  var context = useContext(TabProviderContext);\n  return context === null || context === void 0 ? void 0 : context[0];\n};\n\nvar useRovingTabIndex = function useRovingTabIndex(_ref) {\n  var parentRef = _ref.parentRef,\n      elementSelector = _ref.elementSelector,\n      keepTabIndex = _ref.keepTabIndex,\n      _ref$extraDependencie = _ref.extraDependencies,\n      extraDependencies = _ref$extraDependencie === void 0 ? [] : _ref$extraDependencie;\n  useEffect(function () {\n    var parent = parentRef === null || parentRef === void 0 ? void 0 : parentRef.current;\n\n    if (!parent) {\n      return undefined;\n    }\n\n    var elements = parent.querySelectorAll(elementSelector);\n    var initialFocusableElement = parent === null || parent === void 0 ? void 0 : parent.querySelector(\"\".concat(elementSelector, \"[tabindex=\\\"0\\\"]\"));\n\n    var handleKeyDown = function handleKeyDown(index) {\n      return function (evt) {\n        var newTabFocus = index;\n\n        if (!(evt.key === 'ArrowRight' || evt.key === 'ArrowLeft')) {\n          return;\n        }\n\n        if (evt.key === 'ArrowRight') {\n          // Move right\n          newTabFocus += 1; // If we're at the end, go to the start\n\n          if (newTabFocus >= elements.length) {\n            newTabFocus = 0;\n          }\n        } else if (evt.key === 'ArrowLeft') {\n          // Move left\n          newTabFocus -= 1;\n\n          if (newTabFocus < 0) {\n            // If we're at the start, move to the end\n            newTabFocus = elements.length - 1;\n          }\n        }\n\n        var newElement = elements[newTabFocus];\n        newElement === null || newElement === void 0 ? void 0 : newElement.focus();\n\n        if (keepTabIndex) {\n          evt.currentTarget.setAttribute('tabindex', '-1');\n          newElement === null || newElement === void 0 ? void 0 : newElement.setAttribute('tabindex', '0');\n        }\n      };\n    };\n\n    if ((elements === null || elements === void 0 ? void 0 : elements.length) > 0) {\n      elements.forEach(function (el, key) {\n        // if no element has tabindex set to 0, set the first element as focusable\n        if (!initialFocusableElement && key === 0) {\n          el.setAttribute('tabindex', '0'); // set all other to -1\n        } else if (initialFocusableElement !== el) {\n          el.setAttribute('tabindex', '-1');\n        } // add event listener\n\n\n        el.addEventListener('keydown', handleKeyDown(key));\n      });\n    } // Cleanup listeners\n\n\n    return function () {\n      if ((elements === null || elements === void 0 ? void 0 : elements.length) > 0) {\n        elements.forEach(function (el, key) {\n          el.removeEventListener('keydown', handleKeyDown(key));\n        });\n      }\n    };\n  }, // eslint-disable-next-line react-hooks/exhaustive-deps\n  [parentRef].concat(_toConsumableArray(extraDependencies)));\n};\n\nexport { INIT_STATE as I, TabProviderContext as T, useTabProviderContextState as a, useTabProviderContext as b, reducer as r, useRovingTabIndex as u };","map":{"version":3,"sources":["../../../src/components/tabs/state.ts","../../../src/hooks/useRovingTabIndex.tsx"],"names":["INIT_STATE","isLazy","shouldActivateOnFocus","activeTabIndex","ids","tab","tabPanel","reducer","action","state","payload","type","id","index","tabIds","tabPanelIds","TabProviderContext","createContext","useTabProviderContext","context","useContext","dispatch","useMemo","originalId","uid","useEffect","tabId","tabPanelId","isActive","changeToTab","useCallback","useTabProviderContextState","useRovingTabIndex","parentRef","elementSelector","keepTabIndex","extraDependencies","parent","elements","initialFocusableElement","handleKeyDown","newTabFocus","evt","newElement","key","el"],"mappings":"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","sourcesContent":["import { Dispatch, createContext, useCallback, useContext, useEffect, useMemo } from 'react';\nimport { clamp } from '@lumx/react/utils/clamp';\nimport { uid } from 'uid';\n\ntype TabType = 'tab' | 'tabPanel';\n\nexport interface State {\n    isLazy: boolean;\n    shouldActivateOnFocus: boolean;\n    activeTabIndex: number;\n    ids: Record<TabType, string[]>;\n}\n\nexport const INIT_STATE: State = {\n    isLazy: true,\n    shouldActivateOnFocus: false,\n    activeTabIndex: 0,\n    ids: { tab: [], tabPanel: [] },\n};\n\nexport type Action =\n    | { type: 'update'; payload: Partial<State> }\n    | { type: 'setActiveTabIndex'; payload: number }\n    | { type: 'register'; payload: { type: TabType; id: string } }\n    | { type: 'unregister'; payload: { type: TabType; id: string } };\n\nexport const reducer = (state: State, action: Action): State => {\n    switch (action.type) {\n        case 'update':\n            return { ...state, ...action.payload };\n        case 'setActiveTabIndex': {\n            if (state.activeTabIndex === action.payload) {\n                return state;\n            }\n            // Change active tab index.\n            return { ...state, activeTabIndex: action.payload };\n        }\n        case 'register': {\n            const { type, id } = action.payload;\n            // Append tab/tabPanel id in state.\n            return { ...state, ids: { ...state.ids, [type]: [...state.ids[type], id] } };\n        }\n        case 'unregister': {\n            const { type, id } = action.payload;\n            const index = state.ids[type].indexOf(id);\n            if (index === -1) return state;\n            // Remove tab & tab panel at index.\n            const tabIds = [...state.ids.tab];\n            tabIds.splice(index, 1);\n            const tabPanelIds = [...state.ids.tabPanel];\n            tabPanelIds.splice(index, 1);\n            return {\n                ...state,\n                ids: { tab: tabIds, tabPanel: tabPanelIds },\n            };\n        }\n        default:\n            return state;\n    }\n};\n\nexport const TabProviderContext = createContext<[State, Dispatch<Action>] | null>(null);\n\nexport type TabState = Pick<Required<State>, 'isLazy' | 'shouldActivateOnFocus'> & {\n    isActive: boolean;\n    tabId: string;\n    tabPanelId: string;\n    changeToTab(): void;\n};\n\n/* eslint-disable react-hooks/rules-of-hooks */\nexport const useTabProviderContext = (type: TabType, originalId?: string): undefined | TabState => {\n    const context = useContext(TabProviderContext);\n    if (!context) {\n        return undefined;\n    }\n    const [state, dispatch] = context;\n\n    // Current tab or tab panel id.\n    const id = useMemo(\n        () => originalId || `${type}-${uid()}`,\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        [],\n    );\n    useEffect(\n        () => {\n            // On mount: register tab or tab panel id.\n            dispatch({ type: 'register', payload: { type, id } });\n            return () => {\n                // On unmount: unregister tab or tab panel id.\n                dispatch({ type: 'unregister', payload: { type, id } });\n            };\n        },\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        [],\n    );\n\n    // Find tab/tabPanel index using it's id.\n    const index = useMemo(() => state.ids[type].indexOf(id), [state.ids, type, id]);\n    const tabId = useMemo(() => state.ids.tab[index] || '', [state, index]);\n    const tabPanelId = useMemo(() => state.ids.tabPanel[index] || '', [state, index]);\n    const isActive = useMemo(() => state.activeTabIndex === index, [state, index]);\n    const changeToTab = useCallback(() => dispatch({ type: 'setActiveTabIndex', payload: index }), [dispatch, index]);\n    return {\n        isLazy: state.isLazy,\n        shouldActivateOnFocus: state.shouldActivateOnFocus,\n        tabId,\n        tabPanelId,\n        isActive,\n        changeToTab,\n    };\n};\n\nexport const useTabProviderContextState = (): State | undefined => {\n    const context = useContext(TabProviderContext);\n    return context?.[0];\n};\n","import { RefObject, useEffect } from 'react';\n\ninterface UseRovingTabIndexOptions {\n    parentRef: RefObject<HTMLElement>;\n    elementSelector: string;\n    keepTabIndex?: boolean;\n    /** List of values to be used as extra dependencies of the useEffect */\n    extraDependencies?: any[];\n}\n\nexport const useRovingTabIndex = ({\n    parentRef,\n    elementSelector,\n    keepTabIndex,\n    extraDependencies = [],\n}: UseRovingTabIndexOptions): void => {\n    useEffect(\n        () => {\n            const parent = parentRef?.current;\n            if (!parent) {\n                return undefined;\n            }\n\n            const elements = parent.querySelectorAll(elementSelector) as NodeListOf<HTMLElement>;\n            const initialFocusableElement = parent?.querySelector(`${elementSelector}[tabindex=\"0\"]`);\n\n            const handleKeyDown = (index: number) => (evt: KeyboardEvent) => {\n                let newTabFocus = index;\n                if (!(evt.key === 'ArrowRight' || evt.key === 'ArrowLeft')) {\n                    return;\n                }\n\n                if (evt.key === 'ArrowRight') {\n                    // Move right\n                    newTabFocus += 1;\n                    // If we're at the end, go to the start\n                    if (newTabFocus >= elements.length) {\n                        newTabFocus = 0;\n                    }\n                } else if (evt.key === 'ArrowLeft') {\n                    // Move left\n                    newTabFocus -= 1;\n                    if (newTabFocus < 0) {\n                        // If we're at the start, move to the end\n                        newTabFocus = elements.length - 1;\n                    }\n                }\n                const newElement = elements[newTabFocus];\n                newElement?.focus();\n                if (keepTabIndex) {\n                    (evt.currentTarget as HTMLElement).setAttribute('tabindex', '-1');\n                    newElement?.setAttribute('tabindex', '0');\n                }\n            };\n\n            if (elements?.length > 0) {\n                elements.forEach((el, key) => {\n                    // if no element has tabindex set to 0, set the first element as focusable\n                    if (!initialFocusableElement && key === 0) {\n                        el.setAttribute('tabindex', '0');\n                        // set all other to -1\n                    } else if (initialFocusableElement !== el) {\n                        el.setAttribute('tabindex', '-1');\n                    }\n                    // add event listener\n                    el.addEventListener('keydown', handleKeyDown(key) as EventListener);\n                });\n            }\n\n            // Cleanup listeners\n            return () => {\n                if (elements?.length > 0) {\n                    elements.forEach((el, key) => {\n                        el.removeEventListener('keydown', handleKeyDown(key) as EventListener);\n                    });\n                }\n            };\n        }, // eslint-disable-next-line react-hooks/exhaustive-deps\n        [parentRef, ...extraDependencies],\n    );\n};\n"]},"metadata":{},"sourceType":"module"}