{"ast":null,"code":"import { c as _objectSpread2, b as _extends, f as _slicedToArray, l as onEscapePressed, g as getRootClassName, a as _objectWithoutProperties, d as classnames, h as handleBasicClasses } from './getRootClassName.js';\nimport React, { useMemo, cloneElement, useRef, useState, useEffect, forwardRef } from 'react';\nimport { u as uid } from '../index2.js';\nimport { D as DOCUMENT } from './constants.js';\nimport get from 'lodash/get';\nimport { b as usePopper, P as Placement } from './Popover2.js';\nimport { m as mergeRefs } from './mergeRefs.js';\nimport { createPortal } from 'react-dom';\nimport pull from 'lodash/pull';\nimport debounce from 'lodash/debounce';\n/**\n * Add ref and ARIA attribute(s) in tooltip children or wrapped children.\n * Button, IconButton, Icon and React HTML elements don't need to be wrapped but any other kind of children (array, fragment, custom components)\n * will be wrapped in a <span>.\n *\n * @param  children         Original tooltip anchor.\n * @param  setAnchorElement Set tooltip anchor element.\n * @param  isOpen           Whether the tooltip is open or not.\n * @param  id               Tooltip id.\n * @return tooltip anchor.\n */\n\nvar useInjectTooltipRef = function useInjectTooltipRef(children, setAnchorElement, isOpen, id) {\n  return useMemo(function () {\n    var ariaProps = {\n      'aria-describedby': isOpen ? id : undefined\n    };\n\n    if (children && get(children, '$$typeof') && get(children, 'props.disabled') !== true && get(children, 'props.isDisabled') !== true) {\n      var element = children;\n\n      if (element.ref) {\n        setAnchorElement(element.ref.current);\n      }\n\n      return cloneElement(element, _objectSpread2({}, element.props, {}, ariaProps, {\n        ref: mergeRefs(element.ref, setAnchorElement)\n      }));\n    }\n\n    return React.createElement(\"div\", _extends({\n      className: \"lumx-tooltip-anchor-wrapper\",\n      ref: setAnchorElement\n    }, ariaProps), children);\n  }, [isOpen, id, children, setAnchorElement]);\n};\n/**\n * This singleton handle a global `mouseover` event listener on the `document` in order to toggle tooltips when\n * entering and leaving their anchor element.\n */\n\n\nvar tooltipMouseToggle = function () {\n  /** List of tooltips to toggle on anchor enter/leave. */\n  var tooltips;\n  /** Global listener added on the document. */\n\n  var globalListener;\n\n  function addGlobalListener() {\n    if (globalListener) return;\n    globalListener = debounce(function (evt) {\n      if (!tooltips || !evt.target) return;\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = tooltips[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var _step$value = _step.value,\n              open = _step$value.open,\n              close = _step$value.close,\n              anchorElement = _step$value.anchorElement;\n\n          if (anchorElement.contains(evt.target)) {\n            open();\n          } else {\n            close();\n          }\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n    }, 10);\n    document.addEventListener('mouseover', globalListener);\n  }\n\n  function removeGlobalListener() {\n    if (!globalListener) return;\n    document.removeEventListener('mouseover', globalListener);\n    globalListener = undefined;\n  }\n\n  return {\n    addTooltip: function addTooltip(tooltip) {\n      if (!tooltips) {\n        tooltips = [];\n        addGlobalListener();\n      }\n\n      tooltips.push(tooltip);\n    },\n    removeTooltip: function removeTooltip(actions) {\n      if (!tooltips) return;\n      pull(tooltips, actions);\n\n      if (tooltips.length === 0) {\n        removeGlobalListener();\n        tooltips = undefined;\n      }\n    }\n  };\n}();\n/**\n * Hook controlling tooltip visibility using mouse hover the anchor and delay.\n *\n * @param  delay         Delay in millisecond to display the tooltip.\n * @param  anchorElement Tooltip anchor element.\n * @return whether or not to show the tooltip.\n */\n\n\nfunction useTooltipOpen(delay, anchorElement) {\n  var timer = useRef();\n  var shouldOpen = useRef(false);\n\n  var _useState = useState(false),\n      _useState2 = _slicedToArray(_useState, 2),\n      isOpen = _useState2[0],\n      setIsOpen = _useState2[1];\n\n  useEffect(function () {\n    if (!anchorElement) {\n      return undefined;\n    }\n\n    var tooltip = {\n      anchorElement: anchorElement,\n      open: function open() {\n        if (!shouldOpen.current) {\n          shouldOpen.current = true;\n          timer.current = setTimeout(function () {\n            setIsOpen(shouldOpen.current);\n          }, delay);\n        }\n      },\n      close: function close() {\n        if (timer.current) {\n          clearTimeout(timer.current);\n          timer.current = undefined;\n        }\n\n        if (shouldOpen.current) {\n          shouldOpen.current = false;\n          setIsOpen(shouldOpen.current);\n        }\n      }\n    };\n    var keydown = onEscapePressed(tooltip.close);\n    tooltipMouseToggle.addTooltip(tooltip);\n    anchorElement.addEventListener('focusin', tooltip.open);\n    anchorElement.addEventListener('focusout', tooltip.close);\n    anchorElement.addEventListener('keydown', keydown);\n    return function () {\n      tooltipMouseToggle.removeTooltip(tooltip);\n      anchorElement.removeEventListener('focusin', tooltip.open);\n      anchorElement.removeEventListener('focusout', tooltip.close);\n      anchorElement.removeEventListener('keydown', keydown);\n      tooltip.close();\n    };\n  }, [anchorElement, delay, timer, shouldOpen]);\n  return isOpen;\n}\n/** Position of the tooltip relative to the anchor element. */\n\n/**\n * Component display name.\n */\n\n\nvar COMPONENT_NAME = 'Tooltip';\n/**\n * Component default class name and class prefix.\n */\n\nvar CLASSNAME = getRootClassName(COMPONENT_NAME);\n/**\n * Component default props.\n */\n\nvar DEFAULT_PROPS = {\n  delay: 500,\n  placement: Placement.BOTTOM\n};\n/**\n * Arrow size (in pixel).\n */\n\nvar ARROW_SIZE = 8;\n/**\n * Tooltip component.\n *\n * @param  props Component props.\n * @param  ref   Component ref.\n * @return React element.\n */\n\nvar Tooltip = forwardRef(function (props, ref) {\n  var _ref, _attributes$popper;\n\n  if (!DOCUMENT) {\n    // Can't render in SSR.\n    return null;\n  }\n\n  var label = props.label,\n      children = props.children,\n      className = props.className,\n      delay = props.delay,\n      placement = props.placement,\n      forceOpen = props.forceOpen,\n      forwardedProps = _objectWithoutProperties(props, [\"label\", \"children\", \"className\", \"delay\", \"placement\", \"forceOpen\"]);\n\n  if (!label) {\n    return React.createElement(React.Fragment, null, children);\n  }\n\n  var id = useMemo(function () {\n    return \"tooltip-\".concat(uid());\n  }, []);\n\n  var _useState = useState(null),\n      _useState2 = _slicedToArray(_useState, 2),\n      popperElement = _useState2[0],\n      setPopperElement = _useState2[1];\n\n  var _useState3 = useState(null),\n      _useState4 = _slicedToArray(_useState3, 2),\n      anchorElement = _useState4[0],\n      setAnchorElement = _useState4[1];\n\n  var _usePopper = usePopper(anchorElement, popperElement, {\n    placement: placement,\n    modifiers: [{\n      name: 'offset',\n      options: {\n        offset: [0, ARROW_SIZE]\n      }\n    }]\n  }),\n      styles = _usePopper.styles,\n      attributes = _usePopper.attributes;\n\n  var position = (_ref = attributes === null || attributes === void 0 ? void 0 : (_attributes$popper = attributes.popper) === null || _attributes$popper === void 0 ? void 0 : _attributes$popper['data-popper-placement']) !== null && _ref !== void 0 ? _ref : placement;\n  var isOpen = useTooltipOpen(delay, anchorElement) || forceOpen;\n  var wrappedChildren = useInjectTooltipRef(children, setAnchorElement, isOpen, id);\n  return React.createElement(React.Fragment, null, wrappedChildren, isOpen && createPortal(React.createElement(\"div\", _extends({\n    ref: mergeRefs(ref, setPopperElement)\n  }, forwardedProps, {\n    id: id,\n    role: \"tooltip\",\n    \"aria-label\": label,\n    className: classnames(className, handleBasicClasses({\n      prefix: CLASSNAME,\n      position: position\n    })),\n    style: styles.popper\n  }, attributes.popper), React.createElement(\"div\", {\n    className: \"\".concat(CLASSNAME, \"__arrow\")\n  }), React.createElement(\"div\", {\n    className: \"\".concat(CLASSNAME, \"__inner\")\n  }, label.indexOf('\\n') !== -1 ? label.split('\\n').map(function (sentence) {\n    return React.createElement(\"p\", {\n      key: sentence\n    }, sentence);\n  }) : label)), document.body));\n});\nTooltip.displayName = COMPONENT_NAME;\nTooltip.className = CLASSNAME;\nTooltip.defaultProps = DEFAULT_PROPS;\nexport { Tooltip as T };","map":{"version":3,"sources":["../../../src/components/tooltip/useInjectTooltipRef.tsx","../../../src/components/tooltip/useTooltipOpen.tsx","../../../src/components/tooltip/Tooltip.tsx"],"names":["useInjectTooltipRef","useMemo","ariaProps","isOpen","undefined","children","get","element","setAnchorElement","cloneElement","ref","mergeRefs","tooltipMouseToggle","globalListener","debounce","evt","open","close","anchorElement","tooltips","document","addTooltip","addGlobalListener","removeTooltip","pull","removeGlobalListener","timer","useRef","shouldOpen","setIsOpen","useState","useEffect","tooltip","setTimeout","clearTimeout","keydown","onEscapePressed","COMPONENT_NAME","CLASSNAME","getRootClassName","DEFAULT_PROPS","delay","placement","Placement","BOTTOM","ARROW_SIZE","Tooltip","forwardRef","label","className","forceOpen","forwardedProps","props","id","uid","popperElement","setPopperElement","styles","attributes","usePopper","modifiers","name","options","offset","position","useTooltipOpen","wrappedChildren","createPortal","classNames","handleBasicClasses","prefix","popper","sentence"],"mappings":"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","sourcesContent":["import { mergeRefs } from '@lumx/react/utils/mergeRefs';\nimport get from 'lodash/get';\nimport React, { cloneElement, ReactNode, useMemo } from 'react';\n\n/**\n * Add ref and ARIA attribute(s) in tooltip children or wrapped children.\n * Button, IconButton, Icon and React HTML elements don't need to be wrapped but any other kind of children (array, fragment, custom components)\n * will be wrapped in a <span>.\n *\n * @param  children         Original tooltip anchor.\n * @param  setAnchorElement Set tooltip anchor element.\n * @param  isOpen           Whether the tooltip is open or not.\n * @param  id               Tooltip id.\n * @return tooltip anchor.\n */\nexport const useInjectTooltipRef = (\n    children: ReactNode,\n    setAnchorElement: (e: HTMLDivElement) => void,\n    isOpen: boolean,\n    id: string,\n): ReactNode => {\n    return useMemo(() => {\n        const ariaProps = { 'aria-describedby': isOpen ? id : undefined };\n        if (\n            children &&\n            get(children, '$$typeof') &&\n            get(children, 'props.disabled') !== true &&\n            get(children, 'props.isDisabled') !== true\n        ) {\n            const element = children as any;\n            if (element.ref) {\n                setAnchorElement(element.ref.current);\n            }\n            return cloneElement(element, {\n                ...element.props,\n                ...ariaProps,\n                ref: mergeRefs(element.ref, setAnchorElement),\n            });\n        }\n        return (\n            <div className=\"lumx-tooltip-anchor-wrapper\" ref={setAnchorElement} {...ariaProps}>\n                {children}\n            </div>\n        );\n    }, [isOpen, id, children, setAnchorElement]);\n};\n","import { Callback, onEscapePressed } from '@lumx/react/utils';\nimport { useEffect, useRef, useState } from 'react';\nimport pull from 'lodash/pull';\nimport debounce from 'lodash/debounce';\n\ntype Tooltip = { open: Callback; close: Callback; anchorElement: HTMLElement };\n\n/**\n * This singleton handle a global `mouseover` event listener on the `document` in order to toggle tooltips when\n * entering and leaving their anchor element.\n */\nconst tooltipMouseToggle = (() => {\n    /** List of tooltips to toggle on anchor enter/leave. */\n    let tooltips: Array<Tooltip> | undefined;\n\n    /** Global listener added on the document. */\n    let globalListener: undefined | ((evt: MouseEvent) => void);\n\n    function addGlobalListener() {\n        if (globalListener) return;\n        globalListener = debounce((evt) => {\n            if (!tooltips || !evt.target) return;\n            for (const { open, close, anchorElement } of tooltips) {\n                if (anchorElement.contains(evt.target as any)) {\n                    open();\n                } else {\n                    close();\n                }\n            }\n        }, 10);\n        document.addEventListener('mouseover', globalListener);\n    }\n\n    function removeGlobalListener() {\n        if (!globalListener) return;\n        document.removeEventListener('mouseover', globalListener);\n        globalListener = undefined;\n    }\n\n    return {\n        addTooltip(tooltip: Tooltip) {\n            if (!tooltips) {\n                tooltips = [];\n                addGlobalListener();\n            }\n            tooltips.push(tooltip);\n        },\n        removeTooltip(actions: Tooltip) {\n            if (!tooltips) return;\n            pull(tooltips, actions);\n            if (tooltips.length === 0) {\n                removeGlobalListener();\n                tooltips = undefined;\n            }\n        },\n    };\n})();\n\n/**\n * Hook controlling tooltip visibility using mouse hover the anchor and delay.\n *\n * @param  delay         Delay in millisecond to display the tooltip.\n * @param  anchorElement Tooltip anchor element.\n * @return whether or not to show the tooltip.\n */\nexport function useTooltipOpen(delay: number, anchorElement: HTMLElement | null): boolean {\n    const timer = useRef<number>();\n    const shouldOpen = useRef<boolean>(false);\n    const [isOpen, setIsOpen] = useState(false);\n\n    useEffect(() => {\n        if (!anchorElement) {\n            return undefined;\n        }\n        const tooltip: Tooltip = {\n            anchorElement,\n            open() {\n                if (!shouldOpen.current) {\n                    shouldOpen.current = true;\n                    timer.current = setTimeout(() => {\n                        setIsOpen(shouldOpen.current);\n                    }, delay) as any;\n                }\n            },\n            close() {\n                if (timer.current) {\n                    clearTimeout(timer.current);\n                    timer.current = undefined;\n                }\n                if (shouldOpen.current) {\n                    shouldOpen.current = false;\n                    setIsOpen(shouldOpen.current);\n                }\n            },\n        };\n        const keydown = onEscapePressed(tooltip.close);\n\n        tooltipMouseToggle.addTooltip(tooltip);\n        anchorElement.addEventListener('focusin', tooltip.open);\n        anchorElement.addEventListener('focusout', tooltip.close);\n        anchorElement.addEventListener('keydown', keydown);\n        return () => {\n            tooltipMouseToggle.removeTooltip(tooltip);\n            anchorElement.removeEventListener('focusin', tooltip.open);\n            anchorElement.removeEventListener('focusout', tooltip.close);\n            anchorElement.removeEventListener('keydown', keydown);\n            tooltip.close();\n        };\n    }, [anchorElement, delay, timer, shouldOpen]);\n\n    return isOpen;\n}\n","/* eslint-disable react-hooks/rules-of-hooks */\nimport React, { forwardRef, ReactNode, useMemo, useState } from 'react';\nimport { createPortal } from 'react-dom';\nimport { usePopper } from 'react-popper';\nimport { uid } from 'uid';\n\nimport classNames from 'classnames';\n\nimport { Placement } from '@lumx/react/components/popover/Popover';\n\nimport { DOCUMENT } from '@lumx/react/constants';\n\nimport { Comp, GenericProps, getRootClassName, handleBasicClasses } from '@lumx/react/utils';\nimport { mergeRefs } from '@lumx/react/utils/mergeRefs';\n\nimport { useInjectTooltipRef } from './useInjectTooltipRef';\nimport { useTooltipOpen } from './useTooltipOpen';\n\n/** Position of the tooltip relative to the anchor element. */\nexport type TooltipPlacement = Extract<Placement, 'top' | 'right' | 'bottom' | 'left'>;\n\n/**\n * Defines the props of the component.\n */\nexport interface TooltipProps extends GenericProps {\n    /** Anchor (element on which we activate the tooltip). */\n    children: ReactNode;\n    /** Delay (in ms) before closing the tooltip. */\n    delay?: number;\n    /** Whether the tooltip is displayed even without the mouse hovering the anchor. */\n    forceOpen?: boolean;\n    /** Label text. */\n    label?: string | null | false;\n    /** Placement of the tooltip relative to the anchor. */\n    placement?: TooltipPlacement;\n}\n\n/**\n * Component display name.\n */\nconst COMPONENT_NAME = 'Tooltip';\n\n/**\n * Component default class name and class prefix.\n */\nconst CLASSNAME = getRootClassName(COMPONENT_NAME);\n\n/**\n * Component default props.\n */\nconst DEFAULT_PROPS: Partial<TooltipProps> = {\n    delay: 500,\n    placement: Placement.BOTTOM,\n};\n\n/**\n * Arrow size (in pixel).\n */\nconst ARROW_SIZE = 8;\n\n/**\n * Tooltip component.\n *\n * @param  props Component props.\n * @param  ref   Component ref.\n * @return React element.\n */\nexport const Tooltip: Comp<TooltipProps, HTMLDivElement> = forwardRef((props, ref) => {\n    if (!DOCUMENT) {\n        // Can't render in SSR.\n        return null;\n    }\n    const { label, children, className, delay, placement, forceOpen, ...forwardedProps } = props;\n    if (!label) {\n        return <>{children}</>;\n    }\n\n    const id = useMemo(() => `tooltip-${uid()}`, []);\n\n    const [popperElement, setPopperElement] = useState<null | HTMLElement>(null);\n    const [anchorElement, setAnchorElement] = useState<null | HTMLElement>(null);\n    const { styles, attributes } = usePopper(anchorElement, popperElement, {\n        placement,\n        modifiers: [\n            {\n                name: 'offset',\n                options: { offset: [0, ARROW_SIZE] },\n            },\n        ],\n    });\n\n    const position = attributes?.popper?.['data-popper-placement'] ?? placement;\n    const isOpen = useTooltipOpen(delay as number, anchorElement) || forceOpen;\n    const wrappedChildren = useInjectTooltipRef(children, setAnchorElement, isOpen as boolean, id);\n\n    return (\n        <>\n            {wrappedChildren}\n            {isOpen &&\n                createPortal(\n                    <div\n                        ref={mergeRefs(ref, setPopperElement)}\n                        {...forwardedProps}\n                        id={id}\n                        role=\"tooltip\"\n                        aria-label={label}\n                        className={classNames(className, handleBasicClasses({ prefix: CLASSNAME, position }))}\n                        style={styles.popper}\n                        {...attributes.popper}\n                    >\n                        <div className={`${CLASSNAME}__arrow`} />\n                        <div className={`${CLASSNAME}__inner`}>\n                            {label.indexOf('\\n') !== -1\n                                ? label.split('\\n').map((sentence: string) => <p key={sentence}>{sentence}</p>)\n                                : label}\n                        </div>\n                    </div>,\n                    document.body,\n                )}\n        </>\n    );\n});\nTooltip.displayName = COMPONENT_NAME;\nTooltip.className = CLASSNAME;\nTooltip.defaultProps = DEFAULT_PROPS;\n"]},"metadata":{},"sourceType":"module"}