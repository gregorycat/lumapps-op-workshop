{"ast":null,"code":"import get from 'lodash/get';\n/**\n * Properties of a component to use to determine it's name.\n * In the order of preference.\n */\n\nvar NAME_PROPERTIES = ['type', 'type.displayName', 'displayName', 'name', 'type.name', 'props.mdxType', '_reactInternalFiber.elementType.name'];\n/** LumX Component Type. */\n\n/**\n * Create a predicate function that checks if a ReactNode is a react element from the given component.\n *\n * @param  component React function component or the component name\n * @return predicate returning true if value is instance of the component\n */\n\nvar isComponent = function isComponent(component) {\n  return function (instance) {\n    var componentName = typeof component === 'string' ? component : component.displayName;\n    return !!get(instance, '$$typeof') && NAME_PROPERTIES.some(function (nameProperty) {\n      return get(instance, nameProperty) === componentName;\n    });\n  };\n};\n/**\n * JS falsy values.\n * (excluding `NaN` as it can't be distinguished from `number`)\n */\n\n\nexport { isComponent as i };","map":{"version":3,"sources":["../../../src/utils/type.ts"],"names":["NAME_PROPERTIES","isComponent","componentName","component","get"],"mappings":";AAMA;;;;;AAIA,IAAMA,eAAyB,GAAG,CAAA,MAAA,EAAA,kBAAA,EAAA,aAAA,EAAA,MAAA,EAAA,WAAA,EAAA,eAAA,EAAlC,sCAAkC,CAAlC;AAUA;;AA8BA;;;;;;;IAMaC,WAAW,GAAG,SAAdA,WAAc,CAAA,SAAA,EAAA;AAAA,SAAyC,UAAA,QAAA,EAAmD;AACnH,QAAMC,aAAa,GAAG,OAAA,SAAA,KAAA,QAAA,GAAA,SAAA,GAA4CC,SAAS,CAA3E,WAAA;AAEA,WACI,CAAC,CAACC,GAAG,CAAA,QAAA,EAAL,UAAK,CAAL,IACA,eAAe,CAAf,IAAA,CAAqB,UAAA,YAAA,EAAA;AAAA,aAAmCA,GAAG,CAAA,QAAA,EAAHA,YAAG,CAAHA,KAAnC,aAAA;AAFzB,KAEI,CAFJ;AAHuB,GAAA;AAAA,C;AAS3B","sourcesContent":["import get from 'lodash/get';\nimport { ReactElement, ReactNode, Ref } from 'react';\n\n/** Get types of the values of a record. */\nexport type ValueOf<T extends Record<any, any>> = T[keyof T];\n\n/**\n * Properties of a component to use to determine it's name.\n * In the order of preference.\n */\nconst NAME_PROPERTIES: string[] = [\n    'type',\n    'type.displayName',\n    'displayName',\n    'name',\n    'type.name',\n    'props.mdxType',\n    '_reactInternalFiber.elementType.name',\n];\n\n/** LumX Component Type. */\nexport type Comp<P, T = HTMLElement> = {\n    (props: P & { ref?: Ref<T> }): ReactElement | null;\n    /** React component type. */\n    readonly $$typeof: symbol;\n    /** Component default props. */\n    defaultProps?: Partial<P>;\n    /** Component name. */\n    displayName?: string;\n    /** Component base class name. */\n    className?: string;\n};\n\n/**\n * Define a generic props types.\n */\nexport interface GenericProps {\n    /**\n     * Any prop (particularly any supported prop for a HTML element).\n     * E.g. classNames, onClick, disabled, ...\n     */\n    [propName: string]: any;\n}\n\n/**\n * Callback function type alias (use for readability)\n */\nexport type Callback = () => void;\nexport type Predicate<T> = (t: T) => boolean;\n\n/**\n * Create a predicate function that checks if a ReactNode is a react element from the given component.\n *\n * @param  component React function component or the component name\n * @return predicate returning true if value is instance of the component\n */\nexport const isComponent = <C>(component: Comp<C, any> | string) => (instance: ReactNode): instance is ReactElement => {\n    const componentName = typeof component === 'string' ? component : component.displayName;\n\n    return (\n        !!get(instance, '$$typeof') &&\n        NAME_PROPERTIES.some((nameProperty: string): boolean => get(instance, nameProperty) === componentName)\n    );\n};\n\n/**\n * JS falsy values.\n * (excluding `NaN` as it can't be distinguished from `number`)\n */\nexport type Falsy = false | undefined | null | 0 | '';\n"]},"metadata":{},"sourceType":"module"}