{"ast":null,"code":"import { l as onEscapePressed, i as _toConsumableArray } from './getRootClassName.js';\nimport React, { useEffect, createContext, useContext } from 'react';\nimport isEmpty from 'lodash/isEmpty';\nimport { D as DOCUMENT } from './constants.js';\nimport pull from 'lodash/pull';\n/**\n * Triggers a callback when the escape key is pressed.\n *\n * @param callback      Callback\n * @param closeOnEscape Disables the hook when false\n * @param rootElement   Element on which to listen the escape key\n */\n\nfunction useCallbackOnEscape(callback) {\n  var closeOnEscape = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  var rootElement = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : DOCUMENT === null || DOCUMENT === void 0 ? void 0 : DOCUMENT.body;\n  useEffect(function () {\n    if (closeOnEscape && callback && rootElement) {\n      var onKeyDown = onEscapePressed(callback);\n      rootElement.addEventListener('keydown', onKeyDown);\n      return function () {\n        return rootElement.removeEventListener('keydown', onKeyDown);\n      };\n    }\n\n    return undefined;\n  }, [callback, closeOnEscape, rootElement]);\n}\n\nvar EVENT_TYPES = ['mousedown', 'touchstart'];\n\nfunction isClickAway(target, refs) {\n  // The target element is not contained in any of the listed element references.\n  return !refs.some(function (e) {\n    var _e$current;\n\n    return e === null || e === void 0 ? void 0 : (_e$current = e.current) === null || _e$current === void 0 ? void 0 : _e$current.contains(target);\n  });\n}\n/**\n * Listen to clicks away from the given elements and callback the passed in function.\n *\n * Warning: If you need to detect click away on nested React portals, please use the `ClickAwayProvider` component.\n */\n\n\nfunction useClickAway(_ref) {\n  var callback = _ref.callback,\n      refs = _ref.refs;\n  useEffect(function () {\n    var currentRefs = refs.current;\n\n    if (!callback || !currentRefs || isEmpty(currentRefs)) {\n      return undefined;\n    }\n\n    var listener = function listener(evt) {\n      if (isClickAway(evt.target, currentRefs)) {\n        callback(evt);\n      }\n    };\n\n    EVENT_TYPES.forEach(function (evtType) {\n      return document.addEventListener(evtType, listener);\n    });\n    return function () {\n      EVENT_TYPES.forEach(function (evtType) {\n        return document.removeEventListener(evtType, listener);\n      });\n    };\n  }, [callback, refs]);\n}\n\nvar ClickAwayAncestorContext = createContext(null);\n/**\n * Component combining the `useClickAway` hook with a React context to hook into the React component tree and make sure\n * we take into account both the DOM tree and the React tree we trying to detect click away.\n *\n * @return the react component.\n */\n\nvar ClickAwayProvider = function ClickAwayProvider(_ref) {\n  var children = _ref.children,\n      callback = _ref.callback,\n      refs = _ref.refs;\n  var ancestorChildrenRefs = useContext(ClickAwayAncestorContext);\n  useEffect(function () {\n    var currentRefs = refs.current;\n\n    var _ref2 = ancestorChildrenRefs || {},\n        currentAncestorChildrenRefs = _ref2.current;\n\n    if (!currentAncestorChildrenRefs || !currentRefs) {\n      return undefined;\n    } // Push current refs to parent.\n\n\n    currentAncestorChildrenRefs.push.apply(currentAncestorChildrenRefs, _toConsumableArray(currentRefs));\n    return function () {\n      // Pull current refs from parent.\n      pull.apply(void 0, [currentAncestorChildrenRefs].concat(_toConsumableArray(currentRefs)));\n    };\n  }, [ancestorChildrenRefs, refs]);\n  useClickAway({\n    callback: callback,\n    refs: refs\n  });\n  return React.createElement(ClickAwayAncestorContext.Provider, {\n    value: refs\n  }, children);\n};\n\nClickAwayProvider.displayName = 'ClickAwayProvider';\nexport { ClickAwayProvider as C, useCallbackOnEscape as u };","map":{"version":3,"sources":["../../../src/hooks/useCallbackOnEscape.ts","../../../src/hooks/useClickAway.tsx","../../../src/utils/ClickAwayProvider/ClickAwayProvider.tsx"],"names":["closeOnEscape","rootElement","DOCUMENT","body","useEffect","onKeyDown","onEscapePressed","EVENT_TYPES","e","callback","refs","currentRefs","isEmpty","listener","isClickAway","evt","document","ClickAwayAncestorContext","createContext","ClickAwayProvider","children","ancestorChildrenRefs","useContext","currentAncestorChildrenRefs","pull","useClickAway"],"mappings":"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","sourcesContent":["import { DOCUMENT } from '@lumx/react/constants';\nimport { Callback, onEscapePressed } from '@lumx/react/utils';\nimport { useEffect } from 'react';\n\n/**\n * Triggers a callback when the escape key is pressed.\n *\n * @param callback      Callback\n * @param closeOnEscape Disables the hook when false\n * @param rootElement   Element on which to listen the escape key\n */\nexport function useCallbackOnEscape(\n    callback: Callback | undefined,\n    closeOnEscape = true,\n    rootElement = DOCUMENT?.body,\n) {\n    useEffect(() => {\n        if (closeOnEscape && callback && rootElement) {\n            const onKeyDown = onEscapePressed(callback);\n            rootElement.addEventListener('keydown', onKeyDown);\n            return () => rootElement.removeEventListener('keydown', onKeyDown);\n        }\n        return undefined;\n    }, [callback, closeOnEscape, rootElement]);\n}\n","import { RefObject, useEffect } from 'react';\n\nimport { Falsy } from '@lumx/react/utils';\n\nimport isEmpty from 'lodash/isEmpty';\n\nconst EVENT_TYPES = ['mousedown', 'touchstart'];\n\nfunction isClickAway(target: HTMLElement, refs: Array<RefObject<HTMLElement>>): boolean {\n    // The target element is not contained in any of the listed element references.\n    return !refs.some((e) => e?.current?.contains(target));\n}\n\nexport interface ClickAwayParameters {\n    /**\n     * A callback function to call when the user clicks away from the elements.\n     */\n    callback: EventListener | Falsy;\n    /**\n     * Elements from which we want to detect the click away.\n     */\n    refs: RefObject<Array<RefObject<HTMLElement>>>;\n}\n\n/**\n * Listen to clicks away from the given elements and callback the passed in function.\n *\n * Warning: If you need to detect click away on nested React portals, please use the `ClickAwayProvider` component.\n */\nexport function useClickAway({ callback, refs }: ClickAwayParameters): void {\n    useEffect(() => {\n        const { current: currentRefs } = refs;\n        if (!callback || !currentRefs || isEmpty(currentRefs)) {\n            return undefined;\n        }\n        const listener: EventListener = (evt) => {\n            if (isClickAway(evt.target as HTMLElement, currentRefs)) {\n                callback(evt);\n            }\n        };\n\n        EVENT_TYPES.forEach((evtType) => document.addEventListener(evtType, listener));\n        return () => {\n            EVENT_TYPES.forEach((evtType) => document.removeEventListener(evtType, listener));\n        };\n    }, [callback, refs]);\n}\n","import React, { createContext, useContext, useEffect } from 'react';\nimport pull from 'lodash/pull';\nimport { ClickAwayParameters, useClickAway } from '@lumx/react/hooks/useClickAway';\n\nconst ClickAwayAncestorContext = createContext<ClickAwayParameters['refs'] | null>(null);\n\n/**\n * Component combining the `useClickAway` hook with a React context to hook into the React component tree and make sure\n * we take into account both the DOM tree and the React tree we trying to detect click away.\n *\n * @return the react component.\n */\nexport const ClickAwayProvider: React.FC<ClickAwayParameters> = ({ children, callback, refs }) => {\n    const ancestorChildrenRefs = useContext(ClickAwayAncestorContext);\n\n    useEffect(() => {\n        const { current: currentRefs } = refs;\n        const { current: currentAncestorChildrenRefs } = ancestorChildrenRefs || {};\n        if (!currentAncestorChildrenRefs || !currentRefs) {\n            return undefined;\n        }\n        // Push current refs to parent.\n        currentAncestorChildrenRefs.push(...currentRefs);\n        return () => {\n            // Pull current refs from parent.\n            pull(currentAncestorChildrenRefs, ...currentRefs);\n        };\n    }, [ancestorChildrenRefs, refs]);\n\n    useClickAway({ callback, refs });\n    return <ClickAwayAncestorContext.Provider value={refs}>{children}</ClickAwayAncestorContext.Provider>;\n};\nClickAwayProvider.displayName = 'ClickAwayProvider';\n"]},"metadata":{},"sourceType":"module"}