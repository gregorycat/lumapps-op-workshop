{"ast":null,"code":"import isBoolean from 'lodash/isBoolean';\nimport isEmpty from 'lodash/isEmpty';\nimport kebabCase from 'lodash/kebabCase';\nimport noop from 'lodash/noop';\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\n    return arr2;\n  }\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === \"[object Arguments]\")) {\n    return;\n  }\n\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n}\n\nfunction createCommonjsModule(fn, basedir, module) {\n  return module = {\n    path: basedir,\n    exports: {},\n    require: function (path, base) {\n      return commonjsRequire(path, base === undefined || base === null ? module.path : base);\n    }\n  }, fn(module, module.exports), module.exports;\n}\n\nfunction commonjsRequire() {\n  throw new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');\n}\n\nvar classnames = createCommonjsModule(function (module) {\n  /*!\n    Copyright (c) 2017 Jed Watson.\n    Licensed under the MIT License (MIT), see\n    http://jedwatson.github.io/classnames\n  */\n\n  /* global define */\n  (function () {\n    var hasOwn = {}.hasOwnProperty;\n\n    function classNames() {\n      var classes = [];\n\n      for (var i = 0; i < arguments.length; i++) {\n        var arg = arguments[i];\n        if (!arg) continue;\n        var argType = typeof arg;\n\n        if (argType === 'string' || argType === 'number') {\n          classes.push(arg);\n        } else if (Array.isArray(arg) && arg.length) {\n          var inner = classNames.apply(null, arg);\n\n          if (inner) {\n            classes.push(inner);\n          }\n        } else if (argType === 'object') {\n          for (var key in arg) {\n            if (hasOwn.call(arg, key) && arg[key]) {\n              classes.push(key);\n            }\n          }\n        }\n      }\n\n      return classes.join(' ');\n    }\n\n    if (module.exports) {\n      classNames.default = classNames;\n      module.exports = classNames;\n    } else {\n      window.classNames = classNames;\n    }\n  })();\n});\n/**\n * Enhance isEmpty method to also works with numbers.\n *\n * @param  value The value to check.\n * @return Whether the input value is empty or != 0.\n */\n\nvar _isEmpty = function _isEmpty(value) {\n  if (typeof value === 'number') {\n    return value === 0;\n  }\n\n  return isEmpty(value);\n};\n/**\n * Get the basic CSS class for the given type.\n *\n * @param  prefix The class name prefix for the generated CSS class.\n * @param  type   The type of CSS class we want to generate (e.g.: 'color', 'variant', ...).\n * @param  value  The value of the type of the CSS class (e.g.: 'primary', 'button', ...).\n * @return The basic CSS class.\n */\n\n\nfunction getBasicClass(_ref) {\n  var prefix = _ref.prefix,\n      type = _ref.type,\n      value = _ref.value;\n\n  if (isBoolean(value)) {\n    if (!value) {\n      // False value should not return a class.\n      return '';\n    }\n\n    var booleanPrefixes = ['has', 'is'];\n\n    if (booleanPrefixes.some(function (booleanPrefix) {\n      return type.toString().startsWith(booleanPrefix);\n    })) {\n      return \"\".concat(prefix, \"--\").concat(kebabCase(type));\n    }\n\n    return \"\".concat(prefix, \"--is-\").concat(kebabCase(type));\n  }\n\n  return \"\".concat(prefix, \"--\").concat(kebabCase(type), \"-\").concat(value);\n}\n/**\n * Return all basic LumX CSS classes which are available for every components.\n *\n * @see {@link /src/components/index.d.ts} for the possible values of each parameter.\n *\n * @param  prefix The class name prefix for the generated CSS class.\n * @param  props  All the other props you want to generate a class.\n *                The rule of thumb: the key is the name of the prop in the class, the value a string that will\n *                be used in the classname to represent the value of the given prop.\n * @return All LumX basic CSS classes.\n */\n\n\nfunction handleBasicClasses(_ref2) {\n  var prefix = _ref2.prefix,\n      props = _objectWithoutProperties(_ref2, [\"prefix\"]);\n\n  var otherClasses = {};\n\n  if (!isEmpty(props)) {\n    Object.keys(props).forEach(function (prop) {\n      otherClasses[getBasicClass({\n        prefix: prefix,\n        type: prop,\n        value: props[prop]\n      })] = isBoolean(props[prop]) ? props[prop] : !_isEmpty(props[prop]);\n    });\n  }\n\n  return classnames(prefix, otherClasses);\n}\n/**\n * Checks whether or not the browser support passive events.\n * @see https://github.com/Modernizr/Modernizr/blob/6d56d814b9682843313b16060adb25a58d83a317/feature-detects/dom/passiveeventlisteners.js\n */\n\n\nfunction isPassiveEventAvailable() {\n  var supportsPassiveOption = false;\n\n  try {\n    var opts = Object.defineProperty({}, 'passive', {\n      get: function get() {\n        supportsPassiveOption = true;\n      }\n    });\n    window.addEventListener('testPassiveEventSupport', noop, opts);\n    window.removeEventListener('testPassiveEventSupport', noop, opts);\n  } catch (e) {// ignored\n  }\n\n  return supportsPassiveOption;\n}\n/**\n * Detects horizontal swipe direction without blocking the browser scroll using passive event.\n * @see http://javascriptkit.com/javatutors/touchevents2.shtml\n * @see https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md\n */\n\n\nfunction detectHorizontalSwipe(touchSurface, handleSwipe) {\n  var startX;\n  var startY; // Required min distance traveled to be considered swipe.\n\n  var threshold = 150; // Maximum distance allowed at the same time in perpendicular direction.\n\n  var restraint = 150; // Maximum time allowed to travel that distance.\n\n  var allowedTime = 300;\n  var elapsedTime;\n  var startTime;\n  var finished;\n\n  var onTouchStart = function onTouchStart(evt) {\n    var _Array$from5 = Array.from(evt.changedTouches),\n        _Array$from6 = _slicedToArray(_Array$from5, 1),\n        touch = _Array$from6[0];\n\n    startX = touch.pageX;\n    startY = touch.pageY; // Record time when finger first makes contact with surface.\n\n    startTime = new Date().getTime();\n    finished = false;\n  };\n\n  var onTouchMove = function onTouchMove(evt) {\n    if (finished) {\n      return;\n    }\n\n    elapsedTime = new Date().getTime() - startTime;\n\n    if (elapsedTime > allowedTime) {\n      // Touch swipe too long to be considered.\n      return;\n    }\n\n    var _Array$from7 = Array.from(evt.changedTouches),\n        _Array$from8 = _slicedToArray(_Array$from7, 1),\n        touch = _Array$from8[0]; // Get horizontal dist traveled by finger while in contact with surface.\n\n\n    var distX = touch.pageX - startX; // Get vertical dist traveled by finger while in contact with surface.\n\n    var distY = touch.pageY - startY;\n\n    if (!(Math.abs(distX) >= threshold && Math.abs(distY) <= restraint)) {\n      // Swipe is not horizontal.\n      return;\n    } // Swipe direction.\n\n\n    var direction = distX < 0 ? 'left' : 'right';\n    handleSwipe(direction);\n    finished = true;\n  }; // Activate passive event if possible for better scrolling performance.\n\n\n  var eventOptions = isPassiveEventAvailable() ? {\n    passive: true\n  } : false;\n  touchSurface.addEventListener('touchstart', onTouchStart, eventOptions);\n  touchSurface.addEventListener('touchmove', onTouchMove, eventOptions);\n  return function () {\n    touchSurface.removeEventListener('touchstart', onTouchStart, eventOptions);\n    touchSurface.removeEventListener('touchmove', onTouchMove, eventOptions);\n  };\n}\n/**\n * Make sure the pressed key is the enter key before calling the callback.\n *\n * @param  handler The handler to call on enter/return press.\n * @return The decorated function.\n */\n\n\nfunction onEnterPressed(handler) {\n  return function (evt) {\n    if (evt.key !== 'Enter') {\n      return;\n    }\n\n    handler(evt);\n  };\n}\n/**\n * Make sure the pressed key is the escape key before calling the callback.\n *\n * @param  handler The handler to call on enter/return press.\n * @return The decorated function.\n */\n\n\nfunction onEscapePressed(handler) {\n  return function (evt) {\n    if (evt.key !== 'Escape') {\n      return;\n    }\n\n    handler(evt);\n  };\n}\n/**\n * The prefix to use for the CSS classes.\n */\n\n\nvar CSS_PREFIX = 'lumx';\n/**\n * Animation duration constants. Take into consideration that if you change one of these variables,\n * you need to update their scss counterpart as well\n */\n\nvar DIALOG_TRANSITION_DURATION = 400;\nvar NOTIFICATION_TRANSITION_DURATION = 200;\nvar LAST_PART_CLASSNAME = /^(.*)-(.+)$/gi;\n/**\n * Get the name of the root CSS class of a component based on its name.\n *\n * @param  componentName The name of the component. This name should contains the component prefix and be\n *                       written in PascalCase.\n * @param  subComponent Whether the current component is a sub component, if true, define the class according\n *                      to BEM standards.\n * @return The name of the root CSS class. This classname include the CSS classname prefix and is written in\n *         lower-snake-case.\n */\n\nfunction getRootClassName(componentName, subComponent) {\n  var formattedClassName = \"\".concat(CSS_PREFIX, \"-\").concat(kebabCase(componentName));\n\n  if (subComponent) {\n    return formattedClassName.replace(LAST_PART_CLASSNAME, '$1__$2');\n  }\n\n  return formattedClassName;\n}\n\nexport { CSS_PREFIX as C, DIALOG_TRANSITION_DURATION as D, NOTIFICATION_TRANSITION_DURATION as N, _defineProperty as _, _objectWithoutProperties as a, _extends as b, _objectSpread2 as c, classnames as d, getBasicClass as e, _slicedToArray as f, getRootClassName as g, handleBasicClasses as h, _toConsumableArray as i, createCommonjsModule as j, detectHorizontalSwipe as k, onEscapePressed as l, onEnterPressed as o };","map":{"version":3,"sources":["../../../../../node_modules/classnames/index.js","../../../../lumx-core/src/js/utils.ts","../../../../lumx-core/src/js/constants/index.ts","../../../src/utils/getRootClassName.ts"],"names":["_isEmpty","value","isEmpty","prefix","type","isBoolean","booleanPrefixes","kebabCase","props","otherClasses","Object","getBasicClass","classNames","supportsPassiveOption","opts","get","window","threshold","restraint","allowedTime","onTouchStart","touch","Array","evt","startX","startY","startTime","finished","onTouchMove","elapsedTime","distX","distY","Math","direction","handleSwipe","eventOptions","isPassiveEventAvailable","passive","touchSurface","handler","CSS_PREFIX","DIALOG_TRANSITION_DURATION","NOTIFICATION_TRANSITION_DURATION","LAST_PART_CLASSNAME","formattedClassName"],"mappings":"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","sourcesContent":["/*!\n  Copyright (c) 2017 Jed Watson.\n  Licensed under the MIT License (MIT), see\n  http://jedwatson.github.io/classnames\n*/\n/* global define */\n\n(function () {\n\t'use strict';\n\n\tvar hasOwn = {}.hasOwnProperty;\n\n\tfunction classNames () {\n\t\tvar classes = [];\n\n\t\tfor (var i = 0; i < arguments.length; i++) {\n\t\t\tvar arg = arguments[i];\n\t\t\tif (!arg) continue;\n\n\t\t\tvar argType = typeof arg;\n\n\t\t\tif (argType === 'string' || argType === 'number') {\n\t\t\t\tclasses.push(arg);\n\t\t\t} else if (Array.isArray(arg) && arg.length) {\n\t\t\t\tvar inner = classNames.apply(null, arg);\n\t\t\t\tif (inner) {\n\t\t\t\t\tclasses.push(inner);\n\t\t\t\t}\n\t\t\t} else if (argType === 'object') {\n\t\t\t\tfor (var key in arg) {\n\t\t\t\t\tif (hasOwn.call(arg, key) && arg[key]) {\n\t\t\t\t\t\tclasses.push(key);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn classes.join(' ');\n\t}\n\n\tif (typeof module !== 'undefined' && module.exports) {\n\t\tclassNames.default = classNames;\n\t\tmodule.exports = classNames;\n\t} else if (typeof define === 'function' && typeof define.amd === 'object' && define.amd) {\n\t\t// register as 'classnames', consistent with npm package name\n\t\tdefine('classnames', [], function () {\n\t\t\treturn classNames;\n\t\t});\n\t} else {\n\t\twindow.classNames = classNames;\n\t}\n}());\n","import classNames from 'classnames';\n// eslint-disable-next-line import/no-extraneous-dependencies\nimport React from 'react';\n\nimport isBoolean from 'lodash/isBoolean';\nimport isEmpty from 'lodash/isEmpty';\nimport kebabCase from 'lodash/kebabCase';\nimport noop from 'lodash/noop';\n\n/**\n * Enhance isEmpty method to also works with numbers.\n *\n * @param  value The value to check.\n * @return Whether the input value is empty or != 0.\n */\nconst _isEmpty = (value: any) => {\n    if (typeof value === 'number') {\n        return value === 0;\n    }\n\n    return isEmpty(value);\n};\n\n/**\n * Get the basic CSS class for the given type.\n *\n * @param  prefix The class name prefix for the generated CSS class.\n * @param  type   The type of CSS class we want to generate (e.g.: 'color', 'variant', ...).\n * @param  value  The value of the type of the CSS class (e.g.: 'primary', 'button', ...).\n * @return The basic CSS class.\n */\nexport function getBasicClass({\n    prefix,\n    type,\n    value,\n}: {\n    prefix: string;\n    type: string;\n    value: string | number | boolean | undefined;\n}): string {\n    if (isBoolean(value)) {\n        if (!value) {\n            // False value should not return a class.\n            return '';\n        }\n        const booleanPrefixes = ['has', 'is'];\n\n        if (booleanPrefixes.some((booleanPrefix) => type.toString().startsWith(booleanPrefix))) {\n            return `${prefix}--${kebabCase(type)}`;\n        }\n\n        return `${prefix}--is-${kebabCase(type)}`;\n    }\n\n    return `${prefix}--${kebabCase(type)}-${value}`;\n}\n\n/**\n * Return all basic LumX CSS classes which are available for every components.\n *\n * @see {@link /src/components/index.d.ts} for the possible values of each parameter.\n *\n * @param  prefix The class name prefix for the generated CSS class.\n * @param  props  All the other props you want to generate a class.\n *                The rule of thumb: the key is the name of the prop in the class, the value a string that will\n *                be used in the classname to represent the value of the given prop.\n * @return All LumX basic CSS classes.\n */\nexport function handleBasicClasses({ prefix, ...props }: { prefix: string; [prop: string]: any }): string {\n    const otherClasses: any = {};\n    if (!isEmpty(props)) {\n        Object.keys(props).forEach((prop) => {\n            otherClasses[getBasicClass({ prefix, type: prop, value: props[prop] })] = isBoolean(props[prop])\n                ? props[prop]\n                : !_isEmpty(props[prop]);\n        });\n    }\n\n    return classNames(prefix, otherClasses);\n}\n\ndeclare type SwipeDirection = 'none' | 'up' | 'down' | 'left' | 'right';\n\n/**\n * Detects swipe direction.\n * Credits: http://javascriptkit.com/javatutors/touchevents2.shtml.\n *\n * @deprecated use `detectHorizontalSwipe` instead if possible (better performance and does not block scroll)\n * @param  touchSurface          Element that will hold touch events.\n * @param  handleSwipe Callback function.\n * @return Function to remove listeners.\n */\nexport function detectSwipe(touchSurface: Element, handleSwipe: (direction: SwipeDirection) => void = noop) {\n    let distX: number;\n    let distY: number;\n    let startX: number;\n    let startY: number;\n    let direction: SwipeDirection;\n    // Required min distance traveled to be considered swipe.\n    const threshold = 150;\n    // Maximum distance allowed at the same time in perpendicular direction.\n    const restraint = 100;\n    // Maximum time allowed to travel that distance.\n    const allowedTime = 300;\n    let elapsedTime: number;\n    let startTime: number;\n\n    const onTouchStart = (evt: Event) => {\n        const [touch] = Array.from((evt as TouchEvent).changedTouches);\n        direction = 'none';\n        // Const dist = 0;\n        startX = touch.pageX;\n        startY = touch.pageY;\n        // Record time when finger first makes contact with surface.\n        startTime = new Date().getTime();\n        evt.preventDefault();\n    };\n\n    const onTouchMove = (evt: Event) => {\n        // Prevent scrolling when inside DIV.\n        evt.preventDefault();\n    };\n\n    const onTouchEnd = (evt: Event) => {\n        const [touch] = Array.from((evt as TouchEvent).changedTouches);\n        // Get horizontal dist traveled by finger while in contact with surface.\n        distX = touch.pageX - startX;\n        // Get vertical dist traveled by finger while in contact with surface.\n        distY = touch.pageY - startY;\n        // Get time elapsed.\n        elapsedTime = new Date().getTime() - startTime;\n        if (elapsedTime <= allowedTime) {\n            // First condition for awipe met.\n            if (Math.abs(distX) >= threshold && Math.abs(distY) <= restraint) {\n                // 2nd condition for horizontal swipe met.\n                // If dist traveled is negative, it indicates left swipe.\n                direction = distX < 0 ? 'left' : 'right';\n            } else if (Math.abs(distY) >= threshold && Math.abs(distX) <= restraint) {\n                // 2nd condition for vertical swipe met.\n                // If dist traveled is negative, it indicates up swipe.\n                direction = distY < 0 ? 'up' : 'down';\n            }\n        }\n        handleSwipe(direction);\n        evt.preventDefault();\n    };\n\n    touchSurface.addEventListener('touchstart', onTouchStart, false);\n    touchSurface.addEventListener('touchmove', onTouchMove, false);\n    touchSurface.addEventListener('touchend', onTouchEnd, false);\n\n    return () => {\n        touchSurface.removeEventListener('touchstart', onTouchStart, false);\n        touchSurface.removeEventListener('touchmove', onTouchMove, false);\n        touchSurface.removeEventListener('touchend', onTouchEnd, false);\n    };\n}\n\n/**\n * Checks whether or not the browser support passive events.\n * @see https://github.com/Modernizr/Modernizr/blob/6d56d814b9682843313b16060adb25a58d83a317/feature-detects/dom/passiveeventlisteners.js\n */\nfunction isPassiveEventAvailable() {\n    let supportsPassiveOption = false;\n    try {\n        const opts = Object.defineProperty({}, 'passive', {\n            get() {\n                supportsPassiveOption = true;\n            },\n        });\n        window.addEventListener('testPassiveEventSupport', noop, opts);\n        window.removeEventListener('testPassiveEventSupport', noop, opts);\n    } catch (e) {\n        // ignored\n    }\n    return supportsPassiveOption;\n}\n\n/**\n * Detects horizontal swipe direction without blocking the browser scroll using passive event.\n * @see http://javascriptkit.com/javatutors/touchevents2.shtml\n * @see https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md\n */\nexport function detectHorizontalSwipe(touchSurface: Element, handleSwipe: (direction: 'right' | 'left') => void) {\n    let startX: number;\n    let startY: number;\n    // Required min distance traveled to be considered swipe.\n    const threshold = 150;\n    // Maximum distance allowed at the same time in perpendicular direction.\n    const restraint = 150;\n    // Maximum time allowed to travel that distance.\n    const allowedTime = 300;\n    let elapsedTime: number;\n    let startTime: number;\n    let finished: boolean;\n\n    const onTouchStart = (evt: Event) => {\n        const [touch] = Array.from((evt as TouchEvent).changedTouches);\n        startX = touch.pageX;\n        startY = touch.pageY;\n        // Record time when finger first makes contact with surface.\n        startTime = new Date().getTime();\n        finished = false;\n    };\n\n    const onTouchMove = (evt: Event) => {\n        if (finished) {\n            return;\n        }\n\n        elapsedTime = new Date().getTime() - startTime;\n        if (elapsedTime > allowedTime) {\n            // Touch swipe too long to be considered.\n            return;\n        }\n\n        const [touch] = Array.from((evt as TouchEvent).changedTouches);\n        // Get horizontal dist traveled by finger while in contact with surface.\n        const distX = touch.pageX - startX;\n        // Get vertical dist traveled by finger while in contact with surface.\n        const distY = touch.pageY - startY;\n\n        if (!(Math.abs(distX) >= threshold && Math.abs(distY) <= restraint)) {\n            // Swipe is not horizontal.\n            return;\n        }\n        // Swipe direction.\n        const direction = distX < 0 ? 'left' : 'right';\n\n        handleSwipe(direction);\n        finished = true;\n    };\n\n    // Activate passive event if possible for better scrolling performance.\n    const eventOptions: any = isPassiveEventAvailable() ? { passive: true } : false;\n    touchSurface.addEventListener('touchstart', onTouchStart, eventOptions);\n    touchSurface.addEventListener('touchmove', onTouchMove, eventOptions);\n\n    return () => {\n        touchSurface.removeEventListener('touchstart', onTouchStart, eventOptions);\n        touchSurface.removeEventListener('touchmove', onTouchMove, eventOptions);\n    };\n}\n\ntype KeyboardEventHandler<E extends KeyboardEvent | React.KeyboardEvent> = (event: E) => void;\n\n/**\n * Make sure the pressed key is the enter key before calling the callback.\n *\n * @param  handler The handler to call on enter/return press.\n * @return The decorated function.\n */\nexport function onEnterPressed<E extends KeyboardEvent | React.KeyboardEvent>(\n    handler: KeyboardEventHandler<E>,\n): KeyboardEventHandler<E> {\n    return (evt) => {\n        if (evt.key !== 'Enter') {\n            return;\n        }\n        handler(evt);\n    };\n}\n\n/**\n * Make sure the pressed key is the escape key before calling the callback.\n *\n * @param  handler The handler to call on enter/return press.\n * @return The decorated function.\n */\nexport function onEscapePressed<E extends KeyboardEvent | React.KeyboardEvent>(\n    handler: KeyboardEventHandler<E>,\n): KeyboardEventHandler<E> {\n    return (evt) => {\n        if (evt.key !== 'Escape') {\n            return;\n        }\n        handler(evt);\n    };\n}\n","/**\n * The prefix to use for the CSS classes.\n */\nexport const CSS_PREFIX = 'lumx';\n\n/**\n * Key codes.\n */\nexport * from './keycodes';\n\n/**\n * Animation duration constants. Take into consideration that if you change one of these variables,\n * you need to update their scss counterpart as well\n */\nexport const DIALOG_TRANSITION_DURATION = 400;\nexport const NOTIFICATION_TRANSITION_DURATION = 200;\n","import { CSS_PREFIX } from '@lumx/react/constants';\n\nimport kebabCase from 'lodash/kebabCase';\n\n// See https://regex101.com/r/YjS1uI/3\nconst LAST_PART_CLASSNAME = /^(.*)-(.+)$/gi;\n\n/**\n * Get the name of the root CSS class of a component based on its name.\n *\n * @param  componentName The name of the component. This name should contains the component prefix and be\n *                       written in PascalCase.\n * @param  subComponent Whether the current component is a sub component, if true, define the class according\n *                      to BEM standards.\n * @return The name of the root CSS class. This classname include the CSS classname prefix and is written in\n *         lower-snake-case.\n */\nexport function getRootClassName(componentName: string, subComponent?: boolean): string {\n    const formattedClassName = `${CSS_PREFIX}-${kebabCase(componentName)}`;\n\n    if (subComponent) {\n        return formattedClassName.replace(LAST_PART_CLASSNAME, '$1__$2');\n    }\n    return formattedClassName;\n}\n"]},"metadata":{},"sourceType":"module"}